* Go lang

** Type system

*** Primitive and composite types

| Primitive value types                                 |
|-------------------------------------------------------|
| ~bool~, ~byte = int8~, ~int = int64~, ~uint = uint64~ |
| ~float64~                                             |
| ~rune = int32~, ~string~                              |

| Composite reference types                          |
|----------------------------------------------------|
| src_go{ var arr [3]int } fixed-length array        |
| src_go{ var slc []int } slice = dynamic array      |
| src_go{ var htb map[string]int } map = hash table  |
| src_go{ var ch chan int } concurrency-safe channel |

- Comparable types :: ~a == b~ all primitive types, arrays, pointers, structs of
  comparable types, interfaces, channels. Slices, maps, and funcs are /not
  comparable/: use custom ~Equal()~ implementation

- Type alias :: allows to attach different methods to the same underlying type.
  A type alias implements *nominal typing*

#+BEGIN_SRC go
type Year int // type alias
func (y Year) String() string {
  return fmt.Sprintf("Year %v", int(y))
}
year := Year(2024) // explicit type conversion
fmt.Println(year) // Year 2024, using the String() method
#+END_SRC

*** Constants and enumerations

- Typed constant :: compile-time declaration only for primitive types
  src_go{ const i int = 1 }
- Untyped constant :: compile-time named literal
  src_go{ const c = 1; var i int = c; var f float64 = c }
  - *Immutable values* at runtime: use a /call-by-value/ copy
  - *Mutable values* at runtime: use a /pointer/ to a value
- Enumeration :: a typed list of constants using ~iota~

#+BEGIN_SRC go
type BayanModel int
const (
  Nextra BayanModel = iota + 1 // start from 1, not 0
  Omnia
  Selecta
  Prime
  Spectrum
)
fmt.Println(Nextra, Selecta, Spectrum) // 0, 2, 4
#+END_SRC

*** Variables and pointers

#+BEGIN_SRC go
var i, j int = 1, 2 // typed variables
var i, f = 1, 1.2 // default type for literals int, float64
var b, s, r = false, "ok", 'a' // type inference
var (
  // default initialization to zero value for primitive types
  b bool; i int; f float64; r rune; s string;
  // default initialization to nil for slice/map/chan, pointer/interface/func
  slc []int; htb map[string]int; ch chan int;
)
// short variable declaration: in-function inferred initialization
b, i, f, r, s := true, 1, 1.2, 'a', `ok` // raw string
#+END_SRC

- Pointer :: implies /mutable data/ vs a *call-by-value* copy that preserves
  /immutability/ of original data. Using pointers (implies expensive x10 heap
  allocation and GC cost) to avoid (extremely efficient self-cleaning on stack)
  copies is not necessarily faster. Minimize the on heap allocation of
  variables by reusing objects from ~sync.Pool~
  - *Sharing up escapes to the heap*. All local variables referenced outside of
    a function body are automatically allocated on the heap. Avoid returning
    pointers from a function and sending pointers to a channel
  - *Sharing down stays on the stack*. Forward pointers to local variables to
    function calls

#+BEGIN_SRC go
var i int = 1
var p *int = &i // & address
i++; *p++ // * dereferencing
fmt.Println(i, *p) // 3, 3
#+END_SRC

*** Strings and runes

- String :: a length and a pointer to an immutable array of arbitrary bytes
  - *Charset* Unicode code points: to variable-length *encoding* UTF-8 (up to 4
    bytes)

#+BEGIN_SRC go
var a = 'a' // Unicode rune
var b byte = 'b' // ASCII byte
// 97 a int32, 98 b uint8
fmt.Printf("%[1]v %[1]c %[1]T, %[2]v %[2]c %[2]T", a, b)
a := "single line, escape sequence\n"
b := `multi-line, raw string`
s := "Добро"
for i, b := range s { // byte = uint8
  fmt.Printf("%d:%c ", i, b) // byte index: 0:Д 2:о 4:б 6:р 8:о
}
fmt.Println(s[:2]) // first 2 bytes: Д
for i, r := range []rune(s) { // rune = int32
  fmt.Printf("%d:%c ", i, r) // rune index: 0:Д 1:о 2:б 3:р 4:о
}
fmt.Println(string([]rune(s)[:2])) // first two runes: До
#+END_SRC

*** Arrays

- Array :: a fixed-length contiguous block of memory

#+BEGIN_SRC go
// automatic zero initialization
var a [3]int // 0, 0, 0
// explicit initialization
b := [3]int{} // 0, 0, 0
c := [...]int{1, 2, 3} // 1, 2, 3
// sparse array
d := [...]int{1, 2: 2, 4: 3} // 1, 0, 2, 0, 3
#+END_SRC

*** Slices

- Slice :: a /non-comparable/ *dynamic array*. A slice contains a pointer to an
  array, a length, and a capacity. Slices can provide /multiple views/ into the
  single underlying array. A slice passed by value to a function can be modified
  by a function as a pointer to the underlying array is copied. src_go{ var a
  []int; a[0] } gives the index out of range runtime error
  - *Full slice expression* ~slc[i:j:cap]~ limits side effects of appending by
    reallocating the underlying array when ~len == cap~

#+BEGIN_SRC go
// nil slice
var a []int // []
// increments length, dynamic reallocation
a = append(a, 1, 2) // 1, 2
// explicit initialization
b := []int{1, 2, 3} // 1, 2, 3
// sparse array
c := []int{1, 2: 2, 4: 3} // 1, 0, 2, 0, 3
// zero initialized slice with len == 3, cap == 3
d := make([]int, 3)
for i, v := range []int{1, 2, 3} {
  d[i] = v // 1, 2, 3
}
// empty slice with len == 0, cap == 3
e := make([]int, 0, 3)
for _, v := range []int{1, 2, 3} {
  e = append(e, v) // 1, 2, 3
}
arr := [...]int{1, 2, 3}
// array to slice: shared memory
f := arr[:] // 1, 2, 3
// array to slice: copy
g := make([]int, len(arr))
copy(g, arr[:]) // 1, 2, 3
// slice to array: copy
arr2 := [3]int(f) // 1, 2, 3
#+END_SRC

*** Maps

- Map :: a /non-comparable/ *hash table*. A map contains a pointer on an array
  of buckets, a length, and a capacity. A map passed by value to a function can
  be modified by a function as a pointer to the underlying data structure is
  copied. src_go{ var m map[string]int; m["a"] = 1 } gives the assignment to nil
  runtime error

#+BEGIN_SRC go
// nil map
var a map[string]int
// initialized map
b := map[string]int{"a": 1, "b": 2}
// empty map with len == 0, cap == 3
c := make(map[string]int, 3)
c["a"] = 1
// key exists in a map
if v, exist := c["a"]; exist {
  fmt.Println(v) // 1
}
for k, v := range b {
  fmt.Println(k, v) // a: 1, b: 2
}
// delete key
delete(c, "a")
#+END_SRC

*** Structures

- Structure :: a user-defined data type that implements *nominal typing*

#+BEGIN_SRC go
type Bayan struct {
  Model string
  Year int
}
// constructor function vs struct literal
func NewBayan(model string, year int) *Bayan {
  // local value is allocated on the heap
  // when a pointer to the value is returned from a function
  return &Bayan{model, year}
}
// explicit field names in any order (some may be omitted)
a := Bayan{Model: "Nextra", Year: 2020}
// positional field values (all fileds must be specified)
b := Bayan{"Omnia", 2021}
// anomymous struct, structural typing
var c Bayan = struct{ Model string; Year int }{"Selecta", 2022}
// struct literal
p := &Bayan{Model: "Prime"} // Prime, 0
// constructor function
q := NewBayan("Spectrum", 2024)
// zero Bayan reference
s := new(Bayan)
#+END_SRC

- Struct embedding :: a *composition* of types where fields of embedded types
  are promoted to a containing type
  - *Composition*: an embedded type is a method receiver; a new type is not an
    embedded type
  - *Inheritance*: a subclass is a method receiver; a subclass can substitute a
    superclass

#+BEGIN_SRC go
type Product struct {
  Bayan // embedded field without a name
  Price float64
}
p := Product{Bayan{"Nextra", 2020}, 16e3}
// fields of an embedded type are promoted to a top-level containing type
fmt.Println(p.Model, p.Price, p.Bayan.Year)
#+END_SRC

** Flow control

*** if/else

- ~if/else~ :: allows /arbitrary conditions/ in each clause; each clause has its
  /own scope/
  - Align the happy path to the left; favor early return/break/continue
  - The happy path goes down, while edge cases are handled on the right

#+BEGIN_SRC go
if i := rand.Intn(10); i < 3 {
  fmt.Println(i, "low")
} else if i < 8 {
  fmt.Println(i, "mid")
} else {
  fmt.Println(i, "high")
}
#+END_SRC

*** for/range + break/continue [label]

- ~for/range~ :: provides a wide range of iteration algorithms
  - A controlled iteration with a start, end, and step
  - A loop with dynamic exit condition
  - A loop with unconditional first iteration
  - A loop over strings, arrays, slices, and maps

#+BEGIN_SRC go
// controlled iteration with start, end, and step
for i := 0; i < 3; i++ {
  fmt.Println(i) // 0, 1, 2
}
a := []int{1, 2, 3}
// multiple initialization
for i, l := 0, len(a); i < l; i++ {
  fmt.Println(a[i]) // 1, 2, 3
}
i := 0
// dynamic exit condition
for i < 3 {
  fmt.Println(i) // 0, 1, 2
  i++
}
i = 0
// unconditional first iteration
for {
  fmt.Println(i) // 0, 1, 2
  i++
  if i > 2 {
    break
  }
}
// iterate over strings, arrays, slices, maps
// range returns a copy values not suitable for update: use indexing
for i, v := range []int{1, 2, 3} {
  fmt.Printf("%d: %d\n", i, v) // 0: 1, 1: 2, 2: 3
}
// range expression evaluated once before a loop
a = []int{1, 2, 3}
for range a {
  a = append(a, 9) // 1, 2, 3, 9, 9, 9
}
#+END_SRC

*** switch/case + break label

- ~switch/case~ :: provides conditionals based on equality check or arbitrary
  conditions in each clause

#+BEGIN_SRC go
a := []string{"one", "eleven", "thousand"}
outer: for _, v := range a {
  // equality == check in each clause
  switch l := len(v); l {
  case 1, 2, 3:
    fmt.Println("small")
  case 4, 5, 6:
    fmt.Println("medium")
    break outer
  default:
    fmt.Println("large")
  }
}
for _, v := range a {
  // arbitrary condition in each clause
  switch l := len(v); {
  case l < 4:
    fmt.Println("small")
  case l < 7:
    fmt.Println("medium")
  default:
    fmt.Println("large")
  }
}
#+END_SRC

*** goto label

#+BEGIN_SRC go
for _, v := range []int{1, 2, 3} {
  if v == 2 {
    goto print
  }
  v *= 10
  print: fmt.Println(v) // 10, 2, 30
}
#+END_SRC

** Error handling

*** Error wrapping

- Error :: a type that signals an unexpected yet recoverable situation and
  implements the src_go{ type error interface { Error() string } } interface
  - *Sentinel error* an error value that signals an expected outcome e.g. EOF
  - *Error wrapping* builds a chain of error types that convey additional
    context. Place the %w verb at the end of a wrapping error
  - By returning an ~error~ interface a function can return different error
    types

#+BEGIN_SRC go
// var sentinel error
var ErrInsufficientFunds = errors.New("Insufficient funds")
// const sentinel error
type WalletError string
func (we WalletError) Error() string {
  return string(we)
}
const ErrInsufficientFunds = WalletError("Insufficient funds")
#+END_SRC

#+BEGIN_SRC go
var ErrOh = errors.New("sentinel oh")
// custom error
type OhError struct {
  Msg string
}
// custom error must implement the error interface
func (e OhError) Error() string {
  return e.Msg
}
err := func() error {
  return ErrOh // sentinel error
  return OhError{"custom oh"} // custom error
}()
if errors.Is(err, ErrOh) {
  fmt.Println(err) // sentinel oh
}
var oh OhError
if errors.As(err, &oh) { // casts err into OhError
  fmt.Println(oh.Msg) // custom oh
}
#+END_SRC

#+BEGIN_SRC go
// sentinel error
var ErrDivideByZero = errors.New("divide by zero")
func quoteRem(a, b int) (int, int, error) {
  if b == 0 {
    // return zero values for non-error return types
    return 0, 0, ErrDivideByZero
  }
  // return nil for the error return type
  return a / b, a % b, nil
}
// custom error type
type CustomError struct {
  Msg string
}
// implements the built-in error interface
func (ce CustomError) Error() string {
  return fmt.Sprintf("custom error: %v", ce.Msg)
}
// error wrapping
func wrapError(sentinel bool) error {
  if sentinel {
    // sentinel error: expected outcome
    return ErrDivideByZero
  }
  // error wrapping: additional error context
  return fmt.Errorf("wrapped error: %w", CustomError{"oh"})
}
err := wrapError(false)
if err != nil {
  // check for a sentinel error value in a wrapped chain of errors (==)
  if errors.Is(err, ErrDivideByZero) {
    fmt.Println("sentinel error:", err)
  }
  var ce CustomError
  // check for a custom error type in a wrapped chain of errors (reflection)
  if errors.As(err, &ce) {
    fmt.Println("custom error:", ce.Msg)
  }
}
#+END_SRC

*** panic/recover

- Panic :: signals termination of a program due to an unrecoverable situation.
  On panic execution of functions in a call stack stops, all defer functions are
  executed up until the top of the current goroutine, and then a program
  terminates. A panic unwinds a stack only to the top of the current goroutine,
  so a recover must be within the scope of the current goroutine. Recover must
  be called only inside a defer as only defer functions are executed on panic
  - An application uses a recover to gracefully handle a shutdown
  - A library uses a recover to convert a panic into an error at boundary of a
    public API

#+BEGIN_SRC go
func panicRecover() {
  defer func() {
    // call recover only in defer
    if msg := recover(); msg != nil {
      fmt.Println("panic:", msg)
    }
  }()
  panic("oh") // unrecoverable situation
}
panicRecover()
fmt.Println("continue") // panic: oh, continue
#+END_SRC

** Functions and methods

*** Functions

- Function :: all function parameters including pointers are call-by-value
  copies. A function allows multiple return values
  - *Named return values* mostly for documentation of function types and
    interfaces, and also to access return values e.g. error in ~defer~
  - *Anonymous functions* (function literals) are closures

#+BEGIN_SRC go
// multiple return values
func quoteRem(a, b int) (int, int) {
  return a / b, a % b
}
q, r := quoteRem(5, 3) // 1, 2
// variadic parameters
func sum(vals ...int) int {
  sum := 0
  for _, v := range vals {
    sum += v
  }
  return sum
}
s := sum([]int{1, 2, 3}...) // 6
// function type
type Op func(a, b int) (res int)
// anonymous function: function literal
var sum Op = func(a, b int) int {
  return a + b
}
sum(1, 2) // 3
// anonymous function: closure
for _, v := range []int{1, 2, 3} {
  v := v // variable shadowing, new variable per iteration
  func() {
    // closes over an iteration-local variable
    fmt.Println(v) // 1, 2, 3
  }() // immediately invoked function literal
}
#+END_SRC

- ~defer~ :: defer closures are executed after function return or panic in the
  reverse order. Defer receivers and arguments to defer closures are evaluated
  when declared, not when executed

#+BEGIN_SRC go
// evaluation of defer receivers and arguments
func evalDefer() {
  b := Bayan{"Nextra", 2020}
  // defer value receiver is evaluated when declared
  defer b.Print() // Bayan Nextra 2020
  b = Bayan{"Omnia", 2021}
  i := 1
  // defer arguments are evaluated when declared
  defer fmt.Println(i) // 1
  i = 2
}
// extending error context in defer reqiores named return values
func errorDefer() (err error) {
  err = fmt.Errorf("function oh")
  defer func() {
    if err != nil {
      // captures and wraps function error
      err = fmt.Errorf("defer oh: %w", err)
    }
  }()
  return err // defer oh: function oh
}
#+END_SRC

*** Methods

- Method :: a function that operates on a type value or a type pointer. A method
  can be invoked through a nil pointer receiver (make a zero value useful)
  - src_go{ function(receiver, args...) == receiver.method(args...) }
  - *Pointer receiver* ~(t *T)~ implies mutation of a receiver
  - *Value receiver* ~(t T)~ a method operates on a copy of a receiver
  - Methods of an embedded type are promoted to a containing type

#+BEGIN_SRC go
type Bayan struct {
  Model string
  Year int
}
func (b Bayan) Print() {
  fmt.Printf("Bayan %v %v", b.Model, b.Year)
}
b := Bayan{"Nextra", 2020}
b.Print() // Nextra, 2020
// method value closes over its instance
bPrint := b.Print
bPrint() // Nextra, 2020
// method expression accepts a receiver as the first argument
bPrint2 := Bayan.Print
bPrint2(b)
#+END_SRC

** Interfaces

- Interface :: an abstract type that defines common behavior across distinct
  concrete types. An interface implements type-safe *structural typing* when a
  method set of a concrete type including promoted methods from embedded types
  fully covers all methods defined in an interface. An interface consists of
  - A *static type* an abstract interface type
  - A *dynamic type* concrete value type that implements an interface
  - *Dependency inversion principle* rely on an abstraction, not an
    implementation
  - *Interface segregation principle* the bigger the interface, the weaker the
    abstraction. Abstractions should be discovered, not created. Do not force an
    interface on a producer side: let a consumer discover the right abstractions
    with a minimal set of methods
  - *Robustness principle* accept interfaces (flexible input), return structs
    (compliant output). Exception: error interface
  - *Type assertion* ~v.(Type)~ is applied to an interface at runtime
  - *Type conversion* ~Type(v)~ is applied to a concrete type at compile-time

#+BEGIN_SRC go
type Printer interface {
  Print()
}
type Int int
// a type just implements methods
// that can be used individually or as part of an interface
// a type is totally unaware of any interfaces
func (i Int) Print() {
  fmt.Println("Int", i)
}
type Flo float64
func (f Flo) Print() {
  fmt.Println("Flo", f)
}
// only a client specifies a required interface
vals := []Printer{Int(1), Flo(1.2)}
// process incompatible types through a uniform interface
for _, v := range vals {
  v.Print() // Int 1, Flo 1.2
}
// type assertion to access a dynamic type of an interface
var p Printer = Int(1) // type conversion
if i, assert := p.(Int); assert { // type assertion
  i.Print() // Int 1
}
// type switch to access a dynamic type of an interface
for _, v := range vals {
  switch v.(type) {
  case Int:
    fmt.Print("Integer ")
    v.Print() // Integer Int 1
  case Flo:
    fmt.Print("Float ")
    v.Print() // Float Flo 1.2
  }
}
#+END_SRC

- A function can implement a one-method interface

#+BEGIN_SRC go
// one-method interface
type Logger interface {
  Log(msg string)
}
// function type
type LogFunc func(msg string)
// function type implements a one-method interface
func (lf LogFunc) Log(msg string) {
  lf(msg)
}
// log function
func log(msg string) {
  fmt.Println(msg)
}
// log function == function type == one-method interface
var logger Logger = LogFunc(log)
logger.Log("ok") // ok
#+END_SRC

- Interface embedding :: a composition of abstract types: a containing type
  automatically implements all interfaces implemented by embedded types

#+BEGIN_SRC go
type Negator interface {
  Printer // embedded interface
  Neg()
}
func (i *Int) Neg() {
  ,*i = -*i
}
func (f *Flo) Neg() {
  ,*f = -*f
}
i, f := Int(1), Flo(1.2)
vals := []Negator{&i, &f}
for _, v := range vals {
  v.Neg()
  v.Print() // Int -1, Flo -1.2
}
#+END_SRC

- Dependency injection :: provides external dependencies to a function in form
  of interfaces. Dependency injection fosters separation of concerns e.g. how to
  generate data vs where to write generated data

#+BEGIN_SRC go
func Greet(w io.Writer, name string) {
  fmt.Fprintf(w, "Hello, %v", name)
}
// testing context
func TestGreet(t *testing.T) {
  buf := new(bytes.Buffer)
  Greet(buf, "Vlad") // writes data to a bytes buffer
  got := buf.String()
  exp := "Hello, Vlad"
  if got != exp {
    t.Errorf("got %q, expected %q", got ,exp)
  }
}
// web handler context
func GreetHandler(w http.ResponseWriter, r *http.Request) {
  Greet(w, "Vlad") // writes data to a web response
}
#+END_SRC

** Generics

- Generics :: compile-time automatic generation of type-safe structures,
  functions, and methods
- Generic function :: has type parameters for input arguments and return values

#+BEGIN_SRC go
func Reduce[T, U any](slc []T, i U, acc func(v T, a U) U) U {
  var out U = i
  for _, v := range slc {
    out = acc(v, out)
  }
  return out
}
slc := []int{1, 2, 3, 4, 5}
Reduce(slc, 0, func(v, acc int) int { return v + acc }) // 15

// comparable types support ==, !=, but not <, <=, >, >=
// slice, map, func are not comparable
func Contains[T comparable](slc []T, val T) bool {
  for _, v := range slc {
    if v == val {
      return true
    }
  }
  return false
}
slc := []int{1, 2, 3}
Contains(slc, 2); Contains(slc, 9) // true, false
#+END_SRC

- Type elements and type terms :: type elements define operators supported by a
  type parameter. Supported operators are the intersection of operators from all
  type terms. Type terms match exactly, use =~= to match derived types. Type
  terms can be built-in types, arrays, slices, maps, channels, structs, and
  functions

#+BEGIN_SRC go
func Min[T ~int | ~string](a, b T) T {
  if a < b {
    return a
  }
  return b
}
Min(1, 2), Min("b", "a") // 1, a
#+END_SRC

- Generic struct :: has type parameters for its fields and methods

#+BEGIN_SRC go
type Stack[T any] struct {
  slc []T
}
func (s *Stack[T]) Push(val T) {
  s.slc = append(s.slc, val)
}
func (s *Stack[T]) Pop() (T, bool) {
  var val T
  l := len(s.slc)
  if l == 0 {
    return val, false
  }
  val = s.slc[l - 1]
  s.slc = s.slc[:l - 1]
  return val, true
}
var stk Stack[int]
stk.Push(1); stk.Push(2); stk.Push(3)
for val, nonEmpty := stk.Pop(); nonEmpty; {
  fmt.Println(val) // 3, 2, 1
  val, nonEmpty = stk.Pop()
}
#+END_SRC

- Type constants :: Any interface can be used as a type constraint
  - =T any= unconstrained
  - =T comparable= only equality ==, !=
  - =T ~ind | ~string= intersection of operators <, <=, >,>=
  - =interface= custom operations

#+BEGIN_SRC go
// interface with type elements, supports <, <=, >, >=
type Cmp interface {
  ~int | ~string
}
func Compare[T Cmp](a, b T) int {
  if a < b {
    return -1
  }
  if a > b {
    return 1
  }
  return 0
}

type Node[T Cmp] struct {
  value T
  left, right *Node[T]
}
func (n *Node[T]) Insert(val T) *Node[T] {
  if n == nil {
    return &Node[T]{value: val}
  }
  switch cmp := Compare(val, n.value); {
  case cmp < 0:
    n.left = n.left.Insert(val)
  case cmp > 0:
    n.right = n.right.Insert(val)
  }
  return n
}
func (n *Node[T]) InOrder(f func (val T)) {
  if n != nil {
    n.left.InOrder(f)
    f(n.value)
    n.right.InOrder(f)
  }
}
var n *Node[int]
n = n.Insert(1); n = n.Insert(3); n = n.Insert(2) n = n.Insert(4)
n.InOrder(func (val int) {
  fmt.Printf("%v ", val) // 1, 2, 3, 4
})
#+END_SRC

** Packages and modules

- Package :: a set of types and functions defined in multiple files under a
  package directory. One-word all-lowercase package name should match a package
  directory. Every source file in a package directory must have the same package
  name src_go{ package pkgname }. Top-level Capitalized identifiers are exported
  from a package. Merge packages or create a new common package to resolve
  circular dependencies
  - Import a package src_go{ import "scm/user/mod/pkgdir" }
  - Import alias src_go{ import pkgname "scm/user/mod/pkgdir" }
  - Access an identifier src_go{ pkgname.Identifier }
- Module :: a unit of versioning identified by a repository path
  ~scm/user/mod~. A module represents either
  - *Library* of /importable packages/ src_fish{ go get ... } or
  - *Application* of /executable commands/ src_fish{ go install ... }
    src_go{ package main; func main { ... } }
  - Initialize a module src_fish{ go mod init scm/user/mod }. The ~go.mod~
    defines the current module, a supported Go version, and dependency modules
  - Upgrade module dependencies src_fish{ go mod tidy; go get -u ./... }.
    Synchnonizes ~go.mod~ modules with imported packages from the source code.
    Upgrades patch and minor versions of dependency modules. A different module
    path ~scm/user/mod/v2~ is used to upgrade a module major version
  - Build and run a module during development src_fish{ go run ... }
  - Build a module src_fish{ go build }
  - Static code analysis
    - src_fish{ go install honnef.co/go/tools/cmd/staticcheck@latest }
      src_fish{ staticcheck ./... }
    - src_fish{ go install github.com/mgechev/revive@latest }
      src_fish{ revive ./... }
    - src_fish{ yay -S golangci-lint }
      src_fish{ golangci-lint run }

** Concurrency

- Concurrency :: a *structure* of code to solve a problem with sync steps that
  can be run in parallel ideally without race conditions
- Parallelism :: parallel *execution* of independent sequences of instructions
- CSP (Communicating Sequential Processes) :: (more generic and flexible) a
  randevouz-based system within a single node where anonymous goroutines send
  and receive values over named channels without having to specify the identity
  of a receiver. CSP puts focus on first-class typed sync channels and
  synchronization
- Actor model :: (more specific and complex) a distributed system of named
  actors where actors send and receive messages by specifying the identity of a
  recipient. An actor has an untyped async mailbox and maintains an internal
  mutable state. Actors are combined in a fault-tolerant supervision hierarchies

|---------------------------------+----------------------------|
| CSP                             | Actor model                |
|---------------------------------+----------------------------|
| Machine level architecture      | Cluster level architecture |
| Isolated anonymous goroutines   | Isolated named actors      |
| Typed synchronous channels      | Untyped async mailboxes    |
| Named channels                  | Implicit communication     |
| Channel addressing              | Actor addressing           |
| Multiple channels per goroutine | Single mailbox per actor   |

*** Goroutines

- Goroutine :: an internally sync lightweight thread concurrently executed by
  the Go runtime with other goroutines. Goroutine are non-preemptive, but have
  well-defined preemption points (IO operations, system calls) when a goroutine
  is suspended and resumed. A goroutine accepts parameters, however return
  values are ignored: use channels instead
  - Goroutines follow the fork-join concurrency model, are multiplexed over OS
    threads by a runtime-aware, software-defined, userspace M:N scheduler with
    fast context switching
  - Goroutines run in a single address space, start with a small per-goroutine
    stack that can grow, and take advantage of a low-latency concurrent GC

*** Channels

- Channel :: a first-class, concurrency-safe, composable through ~select/case~
  *bidirectional pipe* that provides sync and async communication between
  goroutines. Multiple goroutines can send and receive from the same channel,
  but each value will be received by exactly one goroutine. A channel is a
  reference type like a slice and a map. A channel orchestrates a transformation
  flow of values with data ownership transfer between concurrent goroutines,
  ensuring that only one goroutine has ownership on specific value at any point
  in time
  - *Unidirectional channel* a send-only src_go{ chan<- int } and a receive-only
    src_go{ <-chan int } channels enforced at compile-time mainly for function
    parameters and local variables. Bidirectional channels are implicitly
    converted to unidirectional channels. A receive-only channel cannot be
    closed
  - *Channel ownership* a goroutine that creates a channel src_go{ ch :=
    make(chan int) } and sends values over a channel has to closes a channel
    src_go{ close(ch) }
  - *Share memory by communicating* over channels, do not communicate by sharing
    memory with mutexes
  - Receive from a closed channel immediately returns a zero value for a channel
    type
  - Send or receive from a nil channel blocks forever
  - Send to a closed channel, close an already closed channel, close a nil
    channel panics
- Unbuffered channel :: (blocking, sync) src_go{ ch := make(chan int) } send
  blocks until receive, receive blocks until send. Only an unbuffered channel
  provides a strong synchronization guarantee and delivery confirmation to a
  sender. A receive from an unbuffered channel happens /before/ a send
  completes: send => receive => send complete
- Buffered channel :: (backpressure, async) src_go{ ch := make(chan int, 1) } an
  efficient async in-memory queue with at most n non-blocking sends or receives.
  A full channel blocks sending, an empty channel blocks receiving. A buffered
  send returns immediately and is not confirmed to a sender

*** select and context

- ~select~ :: enables composition of channels by efficiently and sumltaneously
  sending and receiving values from multiple competing channels in a uniformly
  random way to avoid deadlocks. ~select~ blocks on multiple channels and
  simultaneously and randomly evaluates each clause until the first operation
  completes on any of the channels or a non-blocking ~default~ that is executed
  immediately if present
- ~context~ :: a hierarchical, tree-like (context wrapping/derivation),
  immutable data structure that is used to provide an explicit or
  timeout/deadline-based cancellation from a parent goroutine of multiple child
  goroutines working on a shared context. A received context can be wrapped with
  new cancellation instructions and forwarded to children goroutines without
  affecting a parent goroutine. It is very important to wrap/derive from a
  parent context that is forwarded to children, so cancellations are propagated
  through the call stack. When a context is canceled all derived contexts are
  also canceled. A context can also be used to forward request-scoped meta data
  (invisible dependencies) to children goroutines working on a shared context

#+BEGIN_SRC go
func contextCancelTimeout() {
  var wg sync.WaitGroup
  task := func(ctx context.Context) {
    defer wg.Done()
    for {
      select {
      // a channel is closed when a context is canceled
      case <- ctx.Done(): // immediately returns a zero value when closed
        switch ctx.Err() {
        case context.Canceled:
          fmt.Println("canceled")
        case context.DeadlineExceeded:
          fmt.Println("timeout")
        }
        return
      default: // non-blocking
        fmt.Println("working...")
        time.Sleep(100 * time.Millisecond)
      }
    }
  }
  // cancel context
  ctx, cancel := context.WithCancel(context.Background())
  // once created a cancellable context must be canceled
  defer cancel()
  wg.Add(1)
  go task(ctx)
  time.Sleep(300 * time.Millisecond)
  cancel() // further cancellations are ignored
  wg.Wait()
  // timeout context
  ctx, cancel2 := context.WithTimeout(
    context.Background(), 300 * time.Millisecond,
  )
  defer cancel2()
  wg.Add(1)
  go task(ctx)
  wg.Wait()
}
#+END_SRC

*** Mutex

- Mutex :: provides an exclusive access (synchronization) to a resource shared
  between independent concurrent goroutines. A critical section is a set of
  instructions that has to be executed without interruptions

#+BEGIN_SRC go
func counterMutex() {
  n := 100000
  var cnt int
  var mtx sync.Mutex // make a zero value useful
  var wg sync.WaitGroup
  wg.Add(2)
  go func() {
    defer wg.Done()
    for range n {
      mtx.Lock() // a single writer can hold a write lock, no readers
      cnt++ // write critical section
      mtx.Unlock()
    }
  }()
  go func() {
    defer wg.Done()
    for range n {
      mtx.Lock()
      cnt-- // read critical section
      mtx.Unlock()
    }
  }()
  wg.Wait()
  fmt.Println(cnt)
}
#+END_SRC

- Data race :: interleaving of instructions from two operations that modify the
  same data e.g. two increments (read, update, write) resulting in data
  inconsistency or data corruption when multiple goroutines access the same
  memory location simultaneously and at least one of them is writing. Solution:
  atomic operations, mutex, channel
- Race conditions :: incorrect ordering of two operations modifying the same
  data e.g. two assignments resulting in data inconsistency when a final result
  depends on the ordering of concurrent operations. Solution: channel
- Deadlock :: all goroutines are blocked waiting on one another. Solution:
  ~select/case~. Coffman conditions of a deadlock
  - *Mutual exclusion* a goroutine has an exclusive access to a shared resource
  - *Non-preemption* a shared resource can only be released by a holding
    goroutine
  - *Wait for condition* a goroutine holds a shared resource while waiting for
    another resource
  - *Circular wait* a goroutine waits on a chain of other goroutines that in
    turn wait on the first goroutine

#+BEGIN_SRC go
func deadlock() {
  in, out := make(chan int), make(chan int)
  go func() {
    <- in // blocking receive
    out <- 1
  }()
  <- out // blocking receive - deadlock!
  in <- 2
  select { // no deadlock, simultaneous and random order of cases
  case <- out:
  case in <- 2:
  }
}
#+END_SRC

- Livelock :: two or more goroutines operate, but without making any progress by
  continuously starting and cancelling operations because of the other
  goroutines
- Starvation :: a goroutine cannot get all resources needed to complete a task

*** WaitGroup

- WaitGroup :: a concurrency-safe counter that allows waiting for multiple
  goroutines to complete

#+BEGIN_SRC go
func waitGroup() {
  var wg sync.WaitGroup // make a zero value useful
  wg.Add(1) // increment a counter
  go func() {
    defer wg.Done() // decrement a counter
    time.Sleep(200 * time.Millisecond)
    fmt.Println("a")
  }()
  wg.Add(1)
  go func() {
    defer wg.Done()
    time.Sleep(100 * time.Millisecond)
    fmt.Println("b")
  }()
  wg.Wait() // block a gor until a counter == 0
  fmt.Println("done") // b a done
}
#+END_SRC

*** Conditions

- Condition :: provides a continuous broadcast of values to multiple waiting
  goroutines vs delivery of values over a channel to a single goroutine. A
  condition uses a ~sync.Locker~ to prevent data races on a shared state

#+BEGIN_SRC go
func condBroadcast() {
  var balance int
  cnd := sync.NewCond(new(sync.Mutex))
  listen := func(goal int) {
    cnd.L.Lock()
    // critical section 1: wait for a condition
    for balance < goal { // exit a loop when a condition is met
      // listen for an update. Must be within a critical section
      // cnd.L.Unlock => wait for the next cnd.Broadcast => cnd.L.Lock
      cnd.Wait()
    }
    // critical section 2: a condition is met
    fmt.Printf("goal %v\n", balance)
    cnd.L.Unlock()
  }
  go listen(3)
  go listen(5)
  for i := 0; i < 7; i++ { // producer
    time.Sleep(100 * time.Millisecond)
    cnd.L.Lock()
    balance++ // critical section 2: update a shared state
    cnd.Broadcast() // broadcast an update to all listeners
    cnd.L.Unlock()
  }
}
#+END_SRC

** Testing

- Test public behavior using the black box testing
- Avoid testing private implementation details using the white box testing,
  mocks, and spies e.g. do not test private functions
- Tests are a valuable software asset as they define what a program is doing,
  while a more varying code defines how a program is done
- Property=based testing :: (vs conventional example-based testing) verifies
  domain rules and invariants on automatically generated arbitrary input src_go{
  import "testing/quick" }
- Stub :: static stateless behavior for all requests carefully crafted for each
  test
- Spy :: records a number of calls with call arguments, returned values and
  errors
- Mock :: stateless dynamic behavior on specific requests for controllable
  state + spy, carefully crafter for each test
- Fake :: simplified stateful implementation of a real dependency for all
  requests with decorators or stubs for triggering errors e.g. an in-memory DB.
  A single fake covers all tests for a dependency. Run contract tests against
  fakes and real dependencies
- Test file ~file_test.go~, src_go{ import "testing" }, test function
  ~TestFunc(t *testing.T)~
- Selective testing src_fish{ go test -v -run Test/Sub }
- Test with coverage src_fish{ go test -v -cover -coverprofile=coverage.cov }
- HTML coverage report src_fish{ go tool cover -html=coverage.cov }
- ~t.Errorf()~ continues a test function and collects multiple errors
- ~t.Fatalf()~ exits a test functions and returns the first error

#+BEGIN_SRC go
package main
package main_test // test only public API
import (
  "testing"
  "os"
  "github.com/volodymyrprokopyuk/main" // test only public API
)
var arr []int
func TestMain(m *testing.M) {
  // * before all
  arr = []int{1, 2, 3, 4, 5}
  exitCode := m.Run() // run tests
  // * after all
  arr = arr[:0]
  os.Exit(exitCode)
}
func beforeEach(t *testing.T) []int {
  // * before each
  arr := []int{1, 2, 3, 4, 5}
  // * after each
  t.Cleanup(func() {
    arr = arr[:0]
  })
  return arr
}
func TestReduce(t *testing.T) {
  // test setup
  arr := []int{1, 2, 3, 4, 5}
  // sets teardown
  defer func() {
    arr = arr[:0]
  }()
  // before/after each
  arr := beforeEach(t)
  // test both unexported and exported functions
  res := Reduce(arr, 0, func(v, i int) int { return v + i })
  // test only public API
  res := main.Reduce(arr, 0, func(v, i int) int { return v + i })
  exp := 15
  if res != exp {
    t.Errorf("Reduce: expected %v, got %v", exp, res)
  }
}
#+END_SRC

- Test table :: tests different inputs on the same code

#+BEGIN_SRC go
func TestTableReduce(t *testing.T) {
  cases := []struct {
    name string
    arr []int
    exp int
  }{
    {"empty slice", []int{}, 0},
    {"slice", []int{1, 2, 3}, 6},
  }
  for _, c := range cases {
    c := c // test closure accesses the right test case
    t.Run(c.name, func(t *testing.T) {
      t.Parallel() // run the test in parallel
      res := Reduce(c.arr, 0, func(v, i int) int { return v + i })
      if res != c.exp {
        t.Errorf("Reduce: expected %v, got %v", c.exp, res)
      }
    })
  }
}
#+END_SRC

- Benchmarking :: measures time per operation and memory allocations per
  operation. By default benchmarks are run sequentially
  - Benchmark with memory allocations
    src_fish{ go test -v -bench=. -benchmem -benchtime=2s }

#+BEGIN_SRC go
var blackhole int
func BenchmarkReduce(b *testing.B) {
  for i := 0; i < b.N; i++ {
    blackhole = Reduce(arr, 0, func(v, i int) int { return v + i })
  }
}
#+END_SRC

** Style guide

*** Naming

- ~pkgname~ short, all lowercase package name
- ~pkg.Name()~ short, not repetitive name that uses a context and improves
  callsite reading. Do not repeat a package name in a function name, a method
  receiver in a method name, names of input parameters and return values if
  there is no collision
- ~MaxLength, URLPath, UserID~ exported. ~maxLength, urlPath, userID~ unexported
- ~Counter()~ a getter. ~SetCounter()~ a setter
- Refactor long lines into separate statements, do not split long lines

*** Variables

- Length of a variable is proportional to a scope (the smaller a scope, the
  shorter a variable) and is inversely proportional to a usage frequency (the
  more frequent, the shorter a variable)
- It is fine to reuse variables that are no longer needed e.g. reassign to
  function parameters
- Equivalences
  - src_go{ var i int } and src_go{ i := 0 }
  - src_go{ new(File) } and src_go{ &File{} }
  - src_go{ make(map[string]int) } and src_go{ map[string]int{} }
  - src_go{ fmt.Errorf("oh") } and src_go{ errors.New("oh") }
- Prefer ~var i int~ over ~i := 0~ for a zero value initialization
- Prefer ~a := 1~ over ~var a = 1~ for a non-zero value initialization
- Prefer ~a = 1~ over ~a := 1~ to avoid shadowing in local scopes
- Prefer nil container src_go{ var arr []int } over initialized empty container
  src_go{ var arr = []int{} }. Make the nil value useful src_go{ var wg
  sync.WaitGroup }

*** Interfaces

- Go interfaces generally belong to a consumer not to a provider. An interface
  should be discovered by a consumer, not imposed by a provider. Accept
  interfaces, return concrete types
- Value receiver
  - A receiver is a built-in value type e.g. int, string
  - A method does not modify a receiver
- Pointer receiver
  - A method needs to modify a receiver
  - A receiver contains fields that cannot safely be copied e.g. sync.Mutex
  - A receiver is large
  - A receiver contains a pointer type
  - When in doubt use a pointer receiver
- Make method of a type either all pointer methods or all value methods
- Verify interface compliance for custom types at compile time
  - Value type src_go{ var _ http.Handler = CustomHandler{} }
  - Pointer type src_go{ var _ http.Handler = (*CustomHandler)(nil) }
- Methods with value receivers can be called on pointers and values
- Methods with pointer receivers can only be called on pointers (addressable
  values)

*** Error handling

- Handle errors first on the right src_go{ if err != nil { return } }. Push
  happy path processing to the bottom of a function on the left (without
  indentation)
- Handle type assertion failures src_go{ t, assert := a.(Type) }
- Prefer error over panic: use panic mostly in must-style functions e.g.
  ~MustCompile()~
- ~panic/recover~ is not an error handling strategy
- Use ~defer~ to clean up resources e.g. close files, unlock mutexes
- Call ~os.Exit()~ at most once only in ~main()~. All other functions should
  return errors to signal a failure or multiple exist scenarios. ~defer~
  functions are not executed when ~os.Exit()~ is called

*** Concurrency

- Keep concurrent code within a scope of a sync function that clearly defines
  lifetimes of goroutines. Never start a goroutine without knowing how it will
  stop. There must be a way to signal a goroutine it should stop
