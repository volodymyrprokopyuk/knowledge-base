* Go lang

** Type system

*** Primitive and composite types

| Primitive value types                                  |
|--------------------------------------------------------|
| ~bool~, ~byte = uint8~, ~int = int64~, ~uint = uint64~ |
| ~float64~                                              |
| ~rune = int32~, ~string~                               |

| Composite reference types                          |
|----------------------------------------------------|
| src_go{ var arr [3]int } fixed-length array        |
| src_go{ var slc []int } slice = dynamic array      |
| src_go{ var htb map[string]int } map = hash table  |
| src_go{ var ch chan int } concurrency-safe channel |

- Comparable types :: ~a == b~ all primitive types, arrays, pointers, structs of
  comparable types, interfaces, channels. Slices, maps, and funcs are *not
  comparable*: use custom ~Equal()~ implementation

- Type alias :: allows to attach different methods to the same underlying type.
  A type alias implements *nominal typing*. Built-in types do not have methods,
  but operate with operands

#+BEGIN_SRC go
type Year int // type alias
func (y Year) String() string {
  return fmt.Sprintf("Year %v", int(y))
}
year := Year(2024) // explicit type conversion
fmt.Println(year) // Year 2024, using the String() method
#+END_SRC

- Nominal typing :: two types with the same constituent types but different
  names are different types e.g. type alias, ~struct~
- Structural typing :: two distinct types with the same set of fields and
  methods are treated as the same type e.g. anonymous ~struct~, ~interface~

*** Constants and enumerations

- Typed constant :: compile-time declaration only for primitive types
  src_go{ const i int = 1 }
- Untyped constant :: compile-time named literal
  src_go{ const c = 1; var i int = c; var f float64 = c }
  - *Immutable values* at runtime: use a *call-by-value* copy
  - *Mutable values* at runtime: use a *pointer* to a value
- Enumeration :: a typed list of constants using ~iota~

#+BEGIN_SRC go
type BayanModel int
const (
  Nextra BayanModel = iota + 1 // start from 1, 0 is the default
  Omnia; Selecta
  Prime; Spectrum
)
fmt.Println(Nextra, Selecta, Spectrum) // 1, 3, 5
#+END_SRC

*** Variables and pointers

#+BEGIN_SRC go
var i, j int = 1, 2 // typed variables
var i, f = 1, 1.2 // default type for literals int, float64
var b, s, r = false, "ok", 'a' // type inference
var (
  // default initialization to zero value for primitive types
  b bool; i int; f float64; r rune; s string;
  // default initialization to nil for slice/map/chan, pointer/interface/func
  slc []int; htb map[string]int; ch chan int;
)
// in-function short variable declaration with inferred initialization
b, i, f, r, s := true, 1, 1.2, 'a', `ok` // raw string
#+END_SRC

- Pointer :: implies *mutable data* vs a *call-by-value* copy that preserves
  *immutability* of original data. Using pointers (implies expensive x10 heap
  allocation and GC cost) to avoid (extremely efficient self-cleaning on stack)
  copies is not necessarily faster. Minimize the on heap allocation of
  variables by reusing objects from a cache ~sync.Pool~
  - *Sharing up escapes to the heap*. All local variables referenced outside of
    a function body are automatically allocated on the heap. Avoid returning
    pointers from a function and sending pointers to a channel
  - *Sharing down stays on the stack*. Forward pointers to local variables to
    function calls

#+BEGIN_SRC go
var i int = 1
var p *int = &i // & address
i++; *p++ // * dereferencing
fmt.Println(i, *p) // 3, 3
#+END_SRC

*** Strings and runes

- String :: a length and a pointer to an immutable array of arbitrary bytes
  - *Charset* :: a mapping of Unicode code points: to variable-length *encoding*
    UTF-8 (up to 4 bytes)

#+BEGIN_SRC go
var a = 'a' // Unicode rune
var b byte = 'b' // ASCII byte
// 97 a int32, 98 b uint8
fmt.Printf("%[1]v %[1]c %[1]T, %[2]v %[2]c %[2]T", a, b)
a := "single line, escape sequence\n"
b := `multi-line, raw string`
s := "Добро"
for i, b := range s { // byte = uint8
  fmt.Printf("%d:%c ", i, b) // byte index: 0:Д 2:о 4:б 6:р 8:о
}
fmt.Println(s[:2]) // first 2 bytes: Д
for i, r := range []rune(s) { // rune = int32
  fmt.Printf("%d:%c ", i, r) // rune index: 0:Д 1:о 2:б 3:р 4:о
}
fmt.Println(string([]rune(s)[:2])) // first two runes: До
#+END_SRC

*** Arrays

- Array :: a fixed-length contiguous block of memory

#+BEGIN_SRC go
// automatic zero initialization
var a [3]int // 0, 0, 0
// explicit initialization
b := [3]int{} // 0, 0, 0
c := [...]int{1, 2, 3} // 1, 2, 3
// sparse array
d := [...]int{1, 2: 2, 4: 3} // 1, 0, 2, 0, 3
#+END_SRC

*** Slices

- Slice :: a *non-comparable dynamic array*. A slice contains a pointer to an
  array, a length, and a capacity. Slices can provide multiple views into the
  single underlying array. A slice passed by value to a function can be modified
  by a function as a pointer to the underlying array is copied. src_go{ var a
  []int; a[0] } gives the index out of range runtime error
  - *Full slice expression* ~slc[i:j:cap]~ limits side effects of appending by
    reallocating the underlying array when ~len == cap~

#+BEGIN_SRC go
// nil slice
var a []int // []
// increments length, dynamic reallocation
a = append(a, 1, 2) // 1, 2
// explicit initialization
b := []int{1, 2, 3} // 1, 2, 3
// sparse array
c := []int{1, 2: 2, 4: 3} // 1, 0, 2, 0, 3
// zero initialized slice with len == 3, cap == 3
d := make([]int, 3)
for i, v := range []int{1, 2, 3} {
  d[i] = v // 1, 2, 3
}
// empty slice with len == 0, cap == 3
e := make([]int, 0, 3)
for _, v := range []int{1, 2, 3} {
  e = append(e, v) // 1, 2, 3
}
arr := [...]int{1, 2, 3}
// array to slice: shared memory
f := arr[:] // 1, 2, 3
// array to slice: copy
g := make([]int, len(arr))
copy(g, arr[:]) // 1, 2, 3
// slice to array: copy
arr2 := [3]int(f) // 1, 2, 3
#+END_SRC

*** Maps

- Map :: a *non-comparable hash table*. A map contains a pointer on an array
  of buckets, a length, and a capacity. A map passed by value to a function can
  be modified by a function as a pointer to the underlying data structure is
  copied

#+BEGIN_SRC go
// nil map
var a map[string]int
// initialized map
b := map[string]int{"a": 1, "b": 2}
// empty map with len == 0, cap == 3
c := make(map[string]int, 3)
c["a"] = 1
// key exists in a map
if v, exist := c["a"]; exist {
  fmt.Println(v) // 1
}
for k, v := range b {
  fmt.Println(k, v) // a: 1, b: 2
}
// delete key
delete(c, "a")
#+END_SRC

- A map must be initialized before assignment, however a key lookup can be
  performed on a nil map

#+BEGIN_SRC go
var htb map[string]int // nil map
val, exist := htb["a"] // OK: 0, false
htb["a"] = 1 // error: assignment to nil map
#+END_SRC

*** Structures

- Structure :: a user-defined data type that implements *nominal typing*

#+BEGIN_SRC go
type Bayan struct {
  Model string
  Year int
}
// constructor function vs struct literal
func NewBayan(model string, year int) *Bayan {
  // local value is allocated on the heap
  // when a pointer to the value is returned from a function
  return &Bayan{model, year}
}
// explicit field names in any order (some may be omitted receiving zero value)
a := Bayan{Model: "Nextra", Year: 2020}
// positional field values (all fields must be specified in definition order)
b := Bayan{"Omnia", 2021}
// anomymous struct, structural typing
var c Bayan = struct{ Model string; Year int }{"Selecta", 2022}
// struct literal
p := &Bayan{Model: "Prime"} // Prime, 0
// constructor function
q := NewBayan("Spectrum", 2024)
// zero Bayan reference
s := new(Bayan)
#+END_SRC

- Struct embedding :: *composition* of types where fields of embedded types
  are promoted to a containing type
  - *Composition*: an embedded type is a method receiver; a new type is not an
    embedded type
  - *Inheritance*: a subclass is a method receiver; a subclass can substitute a
    superclass

#+BEGIN_SRC go
type Product struct {
  Bayan // embedded field without a name
  Price float64
}
p := Product{Bayan{"Nextra", 2020}, 16e3}
// fields of an embedded type are promoted to a top-level containing type
fmt.Println(p.Model, p.Price, p.Bayan.Year) // Nextra, 16e3, 2020
#+END_SRC

** Flow control

*** if/else

- ~if/else~ :: allows *arbitrary conditions* in each clause. Each clause has its
  *own scope*
  - Handle first errors and edge cases at the top on the right. Favor early
    ~return~, ~break~, ~continue~
  - Handle the happy path at the bottom on the left
- Type assertion :: ~value.(Type)~ to access a dynamic type of an interface (see
  interfaces below)

#+BEGIN_SRC go
if i := rand.Intn(10); i < 3 {
  fmt.Println(i, "low")
} else if i < 8 {
  fmt.Println(i, "mid")
} else {
  fmt.Println(i, "high")
}
#+END_SRC

*** for/range + break/continue [label]

- ~for/range~ :: provides a wide range of iteration algorithms
  - A loop with unconditional first iteration src_go{ for { ... } }
  - A loop with a dynamic exit condition src_go{ for i < 3 { ... } }
  - A controlled iteration with a start, end, and step src_go{ for i := 0; i <
    3; i++ { ... } }
  - A loop over strings, arrays, slices, and maps src_go{ for i, v := range slc
    { ... } }
  - An iteration N times src_go{ for i := range 3 { ... } }

#+BEGIN_SRC go
// unconditional first iteration
i := 0
for {
  fmt.Println(i) // 0, 1, 2
  i++
  if i > 2 {
    break
  }
}
// dynamic exit condition
i = 0
for i < 3 {
  fmt.Println(i) // 0, 1, 2
  i++
}
// controlled iteration with start, end, and step
for i := 0; i < 3; i++ {
  fmt.Println(i) // 0, 1, 2
}
a := []int{1, 2, 3}
// controlled iteration: multiple initialization
for i, l := 0, len(a); i < l; i++ {
  fmt.Println(a[i]) // 1, 2, 3
}
// iterate over strings, arrays, slices, maps
// range returns a copy values not suitable for update: use indexing
for i, v := range []int{1, 2, 3} {
  fmt.Printf("%v: %v\n", i, v) // 0: 1, 1: 2, 2: 3
}
// range expression evaluated once before iteration
a = []int{1, 2, 3}
for range a {
  a = append(a, 9) // 1, 2, 3, 9, 9, 9
}
// iteration N times
for i := range 3 {
  fmt.Println(1) // 0, 1, 2
}
#+END_SRC

*** Range iterators

- Range iterator :: a function that is called by the ~for/range~ statement and
  yields one value at a time, instead of computing all values at once. The
  iterator signature src_go{ func(yield func(i int, val T) bool) } that can be
  used to report errors to the ~for/range~ loop src_go{ func(yield func(val T,
  err error) bool) }
#+BEGIN_SRC go
func iterator() func(yield func(i, val int) bool) {
  return func(yield func(i, val int) bool) {
    for i, v := range []int{1, 2, 3} {
      if !yield(i, v) {
        return
      }
    }
  }
}
for i, v := range iterator() {
  fmt.Println(i, v) // 0 1, 1 2, 2 3
}
// error handling
for v, err := range iterator() {
  if err != nil {
    return err
  }
  fmt.Println(i, v) // 0 1, 1 2, 2 3
}
#+END_SRC

*** switch/case/default + break label

- ~switch/case/default~ :: provides equality check with multiple options in each
  clause or arbitrary conditions in each clause
- Type switch :: ~value.(type)~ to access a dynamic type of an interface (see
  interfaces below)

#+BEGIN_SRC go
a := []string{"one", "eleven", "thousand"}
outer: for _, v := range a {
  // equality == check in each clause
  switch len(v) {
  case 1, 2, 3:
    fmt.Println("small")
  case 4, 5, 6:
    fmt.Println("medium")
    break outer
  default:
    fmt.Println("large")
  }
}
for _, v := range a {
  // arbitrary condition in each clause
  switch l := len(v); {
  case l < 4:
    fmt.Println("small")
  case l < 7:
    fmt.Println("medium")
  default:
    fmt.Println("large")
  }
}
#+END_SRC

*** goto label

#+BEGIN_SRC go
for _, v := range []int{1, 2, 3} {
  if v == 2 {
    goto print
  }
  v *= 10
  print: fmt.Println(v) // 10, 2, 30
}
#+END_SRC

** Error handling

*** Error wrapping

- Error :: a type that signals an unexpected yet recoverable situation and
  implements the src_go{ type error interface { Error() string } } interface
  - *Sentinel error* an error value that signals an expected outcome e.g. EOF
  - *Error wrapping* builds a chain of error types that convey additional
    context. Place the ~%w~ formatting verb at the end of a wrapping error
  - By returning the ~error~ interface a function can return different error
    types without modifying its signature

#+BEGIN_SRC go
// var sentinel error
var ErrInsufficientFunds = errors.New("Insufficient funds")
// const sentinel error
type WalletError string
func (we WalletError) Error() string {
  return string(we)
}
const ErrInsufficientFunds = WalletError("Insufficient funds")
#+END_SRC

#+BEGIN_SRC go
var ErrOh = errors.New("sentinel oh")
// custom error
type OhError struct {
  Msg string
}
// custom error must implement the error interface
func (e OhError) Error() string {
  return e.Msg
}
err := func() error {
  return ErrOh // sentinel error
  return OhError{"custom oh"} // custom error
}()
if errors.Is(err, ErrOh) {
  fmt.Println(err) // sentinel oh
}
var oh OhError
if errors.As(err, &oh) { // casts err into OhError
  fmt.Println(oh.Msg) // custom oh
}
#+END_SRC

#+BEGIN_SRC go
// sentinel error
var ErrDivideByZero = errors.New("divide by zero")
func quoteRem(a, b int) (int, int, error) {
  if b == 0 {
    // return zero values for non-error return types
    return 0, 0, ErrDivideByZero
  }
  // return nil for the error return type
  return a / b, a % b, nil
}
// custom error type
type CustomError struct {
  Msg string
}
// implements the built-in error interface
func (ce CustomError) Error() string {
  return fmt.Sprintf("custom error: %v", ce.Msg)
}
// error wrapping
func wrapError(sentinel bool) error {
  if sentinel {
    // sentinel error: expected outcome
    return ErrDivideByZero
  }
  // error wrapping: additional error context
  return fmt.Errorf("wrapped error: %w", CustomError{"oh"})
}
err := wrapError(false)
if err != nil {
  // check for a sentinel error value in a wrapped chain of errors (==)
  if errors.Is(err, ErrDivideByZero) {
    fmt.Println("sentinel error:", err)
  }
  var ce CustomError
  // check for a custom error type in a wrapped chain of errors (reflection)
  if errors.As(err, &ce) {
    fmt.Println("custom error:", ce.Msg)
  }
}
#+END_SRC

*** panic/recover

- Panic :: signals termination of a program due to an unrecoverable situation.
  On panic execution of functions in a call stack stops, *all defer functions
  are executed* up until the top of the current goroutine, and then a program
  terminates. A panic unwinds the stack only to the top of the current
  goroutine, so a recover must be within the scope of the current goroutine.
  Recover must be called only inside a defer as only defer functions are
  executed on panic
  - An application uses a recover to gracefully handle a shutdown
  - A library uses a recover to convert a panic into an error at boundary of a
    public API

#+BEGIN_SRC go
func panicRecover() {
  defer func() {
    // call recover only in defer
    if msg := recover(); msg != nil {
      fmt.Println("panic:", msg)
    }
  }()
  panic("oh") // unrecoverable situation
}
panicRecover()
fmt.Println("continue") // panic: oh, continue
#+END_SRC

** Functions and methods

*** Functions

- Function :: all function arguments including pointers are *call-by-value*
  copies. A function allows multiple return values
  - *Named return values* mostly for documentation of function types and
    interfaces, and also to access return values e.g. ~error~ in ~defer~
  - *Anonymous functions* (function literals) are *closures*

#+BEGIN_SRC go
// multiple return values
func quoteRem(a, b int) (int, int) {
  return a / b, a % b
}
q, r := quoteRem(5, 3) // 1, 2
// variadic parameters
func sum(vals ...int) int {
  sum := 0
  for _, v := range vals {
    sum += v
  }
  return sum
}
s := sum([]int{1, 2, 3}...) // 6
// function type, named return value for documentation
type Op func(a, b int) (res int)
// anonymous function: function literal
var sum Op = func(a, b int) int {
  return a + b
}
sum(1, 2) // 3
// anonymous function: closure
for _, v := range []int{1, 2, 3} {
  v := v // variable shadowing, new variable per iteration
  func() {
    // closes over an iteration-local variable
    fmt.Println(v) // 1, 2, 3
  }() // immediately invoked function literal
}
#+END_SRC

- ~defer~ :: defer *closures* are executed after function ~return~ or ~panic~ in
  the reverse order. Defer receivers and arguments to defer closures are
  *evaluated when declared*, not when executed

#+BEGIN_SRC go
// evaluation of defer receivers and arguments
func evalDefer() {
  b := Bayan{"Nextra", 2020}
  // defer value receiver is evaluated when declared
  defer b.Print() // Bayan Nextra 2020
  b = Bayan{"Omnia", 2021}
  i := 1
  // defer arguments are evaluated when declared
  defer fmt.Println(i) // 1
  i = 2
}
// extending error context in defer requires named return values
func errorDefer() (err error) {
  err = fmt.Errorf("function oh")
  defer func() {
    if err != nil {
      // captures and wraps function error
      err = fmt.Errorf("defer oh: %w", err)
    }
  }()
  return err // defer oh: function oh
}
#+END_SRC

*** Methods

- Method :: a function that operates on a *receiver* which is either a *type
  value* or a *type pointer*. A method can be invoked through a nil pointer
  receiver (make a zero value useful)
  - src_go{ function(receiver, args...) == receiver.method(args...) }
  - *Pointer receiver* ~(t *T)~ implies *mutation* of a receiver
  - *Value receiver* ~(t T)~ a method operates on a *copy* of a receiver
  - Methods of an embedded type are promoted to a containing type

#+BEGIN_SRC go
type Bayan struct {
  Model string
  Year int
}
func (b Bayan) Print() {
  fmt.Printf("Bayan %v %v", b.Model, b.Year)
}
b := Bayan{"Nextra", 2020}
b.Print() // Nextra, 2020
// method value closes over its instance
bPrint := b.Print
bPrint() // Nextra, 2020
// method expression accepts a receiver as the first argument
bPrint2 := Bayan.Print
bPrint2(b)
#+END_SRC

** Interfaces

*** Structural typing

- Interface :: an abstract type that defines common set of methods across
  distinct concrete types e.g. type alias, struct. Primitive data ~int/string~
  to a single ~func~, as composite data ~type struct~ to a set of functions
  ~type interface~. An interface implements type-safe *structural typing* when a
  method set of a concrete type including promoted methods from embedded types
  fully covers all methods defined in an interface. An interface can be
  implemented by a type alias or a struct. Built-in types cannot directly
  implement an interface (use a type alias)
- An interface implies inefficiency due to the indirection between a static
  interface type and a dynamic concrete type (vs genericis do not have
  indirection). Interface methods can be attached to a type alias, or a struct,
  but cannot be attached to a built-in times e.g. int. An interface consists of
  - *Static type* an abstract interface type
  - *Dynamic type* a concrete value type that implements the interface
  - *Dependency inversion principle* rely on an abstraction, not an
    implementation
  - *Interface segregation principle* the bigger the interface, the weaker the
    abstraction. Abstractions should be discovered, not defined. Do not force an
    interface on a producer side: let a consumer discover the right abstractions
    with a minimal set of methods
  - *Robustness principle* accept interfaces (flexible input), return structs
    (compliant output). Exception: ~error~ interface
  - *Type assertion* ~value.(Type)~ is applied to an interface at runtime
  - *Type conversion* ~Type(v)~ is applied to a concrete type at compile-time

#+BEGIN_SRC go
type Printer interface {
  Print()
}
type Int int
// a type just implements methods
// that can be used individually or as part of an interface
// a type is totally unaware of any interfaces
func (i Int) Print() {
  fmt.Println("Int", i)
}
type Flo float64
func (f Flo) Print() {
  fmt.Println("Flo", f)
}
// only a client specifies a required interface
vals := []Printer{Int(1), Flo(1.2)}
// process incompatible types through a uniform interface
for _, v := range vals {
  v.Print() // Int 1, Flo 1.2
}
// type assertion to access a dynamic type of an interface
var p Printer = Int(1) // type conversion
if i, assert := p.(Int); assert { // type assertion
  i.Print() // Int 1
}
// type switch to access a dynamic type of an interface
for _, v := range vals {
  switch v.(type) {
  case Int:
    fmt.Print("Integer ")
    v.Print() // Integer Int 1
  case Flo:
    fmt.Print("Float ")
    v.Print() // Float Flo 1.2
  }
}
#+END_SRC

*** One-method interface

- A function can implement a one-method interface

#+BEGIN_SRC go
// one-method interface
type Logger interface {
  Log(msg string)
}
// function type
type LogFunc func(msg string)
// function type implements a one-method interface
func (lf LogFunc) Log(msg string) {
  lf(msg)
}
// log function
func log(msg string) {
  fmt.Println(msg)
}
// log function == function type == one-method interface
var logger Logger = LogFunc(log)
logger.Log("ok") // ok
#+END_SRC

*** Interface embedding

- Interface embedding :: *composition* of abstract types: a containing interface
  automatically has all methods from embedded interfaces

#+BEGIN_SRC go
type Negator interface {
  Printer // embedded interface
  Neg()
}
func (i *Int) Neg() {
  *i = -*i
}
func (f *Flo) Neg() {
  *f = -*f
}
i, f := Int(1), Flo(1.2)
vals := []Negator{&i, &f}
for _, v := range vals {
  v.Neg()
  v.Print() // Int -1, Flo -1.2
}
#+END_SRC

*** Dependency injection

- Dependency injection :: provides external dependencies to a function in a form
  of interfaces. *Robustness principle* accept interfaces, return structs.
  Dependency injection fosters separation of concerns e.g. a function defines
  how to generate data vs an interface argument dynamically specifies where to
  write generated data

#+BEGIN_SRC go
func Greet(w io.Writer, name string) {
  fmt.Fprintf(w, "Hello, %v", name)
}
// bytes buffer context
func GreetBuffer() {
  var buf bytes.Buffer
  Greet(&buf, "Vlad") // writes data to a bytes buffer
  fmt.Println(buf.String()) // Hello, Vlad
}
// web handler context
func GreetHandler(w http.ResponseWriter, r *http.Request) {
  Greet(w, "Vlad") // writes data to a web response
}
#+END_SRC

** Generics

*** Generic functions

- Generics :: compile-time automatic generation of type-safe types, structures,
  functions, and methods
- Generic function :: has type parameters for input arguments and return values.
  A generic function is not a Go function, but a *template* used by the Go
  compiler to instantiate Go functions on either concrete types or interfaces. A
  generic function accepts input arguments and returns return values of
  unspecified or constrained types, not known at the time of definition of a
  generic algorithm

#+BEGIN_SRC go
func Map[T any](fun func(val T) T, slc []T) []T {
  res := make([]T, len(slc))
  for i, val := range slc {
    res[i] = fun(val)
  }
  return res
}
func Filter[T any](slc []T, prd func(val T) bool) []T {
  res := make([]T, 0, len(slc))
  for _, val := range slc {
    if prd(val) {
      res = append(res, val)
    }
  }
  return res
}
func Reduce[T, U any](slc []T, fun func(val T, res U) U, init U) U {
  for _, val := range slc {
    init = fun(val, init)
  }
  return init
}
slc := []int{1, 2, 3, 4, 5}
fmt.Println(Reduce(slc, func(val, res int) int { return val + res }, 0)) // 15
func Compose[T, U, V any](f func(val T) U, g func(val U) V) func(val T) V {
  return func(val T) V {
    return g(f(val))
  }
}
fun := Compose(
  func(val int) float64 { return float64(val) * 2.0 },
  func(val float64) string { return fmt.Sprintf("val: %v", val) },
)
fmt.Println(fun(1)) // val: 2
// comparable types support ==, !=, but not <, <=, >, >= operators
// slice, map, func are not comparable
func Contains[T comparable](slc []T, val T) bool {
  for _, e := range slc {
    if e == val {
      return true
    }
  }
  return false
}
slc := []int{1, 2, 3}
Contains(slc, 2); Contains(slc, 9) // true, false
#+END_SRC

*** Type elements

- Type element :: a union or an intersection of type terms that defines a set of
  *operators* on built-in types supported by a type parameter. Supported
  operators are an *intersection* of operators from all type terms. *Type term*
  a built-in type, a type approximation, an interface, or a type element. Type
  terms match types exactly, use a =~type approximation= to match derived types
  e.g. type aliases
- Union type element :: union of type terms combines built-in types, arrays,
  slices, maps, channels, structs, functions, interfaces, and other type
  elements

#+BEGIN_SRC go
type Integer interface {
  int | int32 | int64
}
type Float interface {
  float32 | float64
}
type Number interface {
  Integer | Float // type elements are type terms
}
func Neg[T Number](val T) T {
  return -val // type element enables operators on type parameters
}
fmt.Println(Neg(1), Neg(1.2)) // -1, -1.2
func Positive[T Number](val T) bool {
  return val > 0 // enables operators on type parameters
}
fmt.Println(Positive(1), Positive(-1.2)) // true, false
#+END_SRC

- Intersection type element :: intersection of type terms

#+BEGIN_SRC go
type IntStringer interface {
  ~int // both derived from int AND having String() method
  String() string
}
type Int int
func (i Int) String() string {
  return fmt.Sprintf("Int %v", int(i))
}
func PrintInt[T IntStringer](val T) {
  fmt.Println(val.String())
}
PrintInt(Int(1)) // Int 1, int only does not satisfy type constraint
#+END_SRC

- Constraint literal :: inline anonymous type element

#+BEGIN_SRC go
func Min[T ~int | ~string](a, b T) T {
  if a < b {
    return a
  }
  return b
}
Min(1, 2), Min("b", "a") // 1, a
func PrintInt[T interface { ~int; String() string }](val T) { // IntStringer
  fmt.Println(val.String())
}
PrintInt(Int(1)) // Int 1, int only does not satisfy type constraint
#+END_SRC

- Self-referential constraint literal :: refers to T inside the interface
  itself. Must be defined (the only possible way) as an anonymous constraint
  literal in order to reference T

#+BEGIN_SRC go
type Int int
func (i Int) Equal(val Int) bool {
  return i == val
}
func Contains[T interface { Equal(val T) bool }](slc []T, val T) bool {
  for _, v := range slc {
    if v.Equal(val) {
      return true
    }
  }
  return false
}
fmt.Println(Contains([]Int{1, 2}, 2), Contains([]Int{1, 2}, 9)) // true, false
#+END_SRC

*** Generic structs

- Generic struct :: has type parameters for struct fields and methods. Generic
  types are always instantiated for concrete types at compile time
- Generic methods :: cannot have type parameters other than type parameters
  defined in the struct

#+BEGIN_SRC go
// generic struct and slice
type Stack[T any] struct {
  slc []T // homogeneous slice of any but, single type
  // vs ~slc []any~ = heterogeneous slice of different types
}
func (s *Stack[T]) Push(val T) {
  s.slc = append(s.slc, val)
}
func (s *Stack[T]) Pop() (T, bool) {
  var val T
  l := len(s.slc)
  if l == 0 {
    return val, false
  }
  val = s.slc[l - 1]
  s.slc = s.slc[:l - 1]
  return val, true
}
var stk Stack[int]
stk.Push(1); stk.Push(2); stk.Push(3)
for val, more := stk.Pop(); more; {
  fmt.Println(val) // 3, 2, 1
  val, more = stk.Pop()
}
// generic map
type Index[K comparable, V any] map[K]V
idx := make(Index[string, int])
idx["a"] = 1
fmt.Println(idx["a"])
#+END_SRC

- Generic interface ::

#+BEGIN_SRC go
type Equaler[T any] interface {
  Equal(val T) bool
}
type Int int
func (i Int) Equal(val Int) bool {
  return i == val
}
func Contains[T Equaler[T]](slc []T, val T) bool {
  for _, v := range slc {
    if v.Equal(val) {
      return true
    }
  }
  return false
}
fmt.Println(Contains([]Int{1, 2}, 2), Contains([]Int{1, 2}, 9)) // true, false
#+END_SRC

*** Type constraints

- Type constraints :: any *interface* can be used as a type constraint. An
  interface either defines a set of *method elements* (is usually used to define
  common behavior across different types) that a type parameter must implement,
  or a set of *type elements* (can only be used as a type constraint) that, in
  turn, specify a set of allowed operators on type parameters
  - Any ~[T any]~ unconstrained. The broader the constraint, the more types it
    allows, the less operations can be guaranteed to be supported
  - Comparable ~[T comparable]~ comparable, but unordered types that support
    only equality ==, != e.g. bool, struct of only comparable fields. Go
    operators do not call methods, hence there is no way to manually define an
    interface equivalent to a language-provided ~comparable~ that also works
    with user-defined comparable structs
  - Type elements =[T ~int | ~string]=, ~[T cmp.Ordered]~ intersection of
    operators <, <=, >,>=. ~cmp.Ordered~ is ~comparable~ but not vice versa
  - Type constraints ~[T interface]~ custom methods

#+BEGIN_SRC go
// interface with type elements, supports <, <=, >, >=
type Cmp interface {
  ~int | ~string
}
func Compare[T Cmp](a, b T) int {
  if a < b {
    return -1
  }
  if a > b {
    return 1
  }
  return 0
}
type Node[T Cmp] struct {
  value T
  left, right *Node[T]
}
func (n *Node[T]) Insert(val T) *Node[T] {
  if n == nil {
    return &Node[T]{value: val}
  }
  switch cmp := Compare(val, n.value); {
  case cmp < 0:
    n.left = n.left.Insert(val)
  case cmp > 0:
    n.right = n.right.Insert(val)
  }
  return n
}
func (n *Node[T]) InOrder(f func (val T)) {
  if n != nil {
    n.left.InOrder(f)
    f(n.value)
    n.right.InOrder(f)
  }
}
var n *Node[int]
n = n.Insert(1); n = n.Insert(3); n = n.Insert(2) n = n.Insert(4)
n.InOrder(func (val int) {
  fmt.Printf("%v ", val) // 1, 2, 3, 4
})
#+END_SRC

** Packages and modules

*** Packages

- Package :: a set of types, functions, and methods defined in multiple files
  under a package directory. One-word all-lowercase package name should match a
  package directory. Every source file in a package directory must have the same
  package name src_go{ package pkgname }. Top-level Capitalized identifiers are
  exported from a package. Merge packages or create a new common package to
  resolve circular dependencies
  - Import a package src_go{ import "scm/user/mod/pkgdir" }
  - Import alias src_go{ import pkgname "scm/user/mod/pkgdir" }
  - Access an identifier src_go{ pkgname.Identifier }

*** Modules

- Module :: a unit of versioning identified by a repository path
  ~scm/user/mod~. A module represents either
  - *Library* of *importable packages* src_fish{ go get ... } or
  - *Application* of *executable commands* src_fish{ go install ... }
    src_go{ package main; func main { ... } }
  - src_fish{ go mod init scm/user/mod } initializes a module in the current
    directory. The ~go.mod~ file defines the current module name, a supported Go
    version, and module dependencies
  - src_fish{ go get -u ./...; go mod tidy } upgrades patch and minor versions
    module dependencies and synchnonizes ~go.mod~ with imported packages from
    the source code. A different module path ~scm/user/mod/v2~ is used to
    upgrade a module major version without changing the module name
  - src_fish{ go run ... } builds and runs a module during development
  - src_fish{ go build } builds a module into a self contained executable

*** Static code analysis

- src_fish{ yay -S golangci-lint }
  src_fish{ golangci-lint run ./... }

** Concurrency

- Concurrency :: a *structure* of code to solve a problem with sync steps that
  can be run in parallel ideally without data races and race conditions
- Parallelism :: parallel *execution* of independent sequences of instructions
- CSP (Communicating Sequential Processes) :: (more generic and more flexible) a
  randevouz-based system within a *single node* where *anonymous goroutines*
  send and receive values over *named channels* without having to specify the
  identity of a receiver. CSP puts focus on *first-class typed sync channels*
  and synchronization
- Actor model :: (more specific and more complex) a *distributed system* of
  *named actors* with *implicit hidden communication* where actors send and
  receive messages by specifying the identity of a recipient. An actor has an
  *untyped async mailbox* and maintains an internal mutable state. Actors are
  combined in *fault-tolerant supervision hierarchies*

|---------------------------------+----------------------------|
| CSP                             | Actor model                |
|---------------------------------+----------------------------|
| Machine level architecture      | Cluster level architecture |
| Isolated anonymous goroutines   | Isolated named actors      |
| Typed synchronous channels      | Untyped async mailboxes    |
| Named channels                  | Implicit communication     |
| Channel addressing              | Actor addressing           |
| Multiple channels per goroutine | Single mailbox per actor   |

*** Goroutines

- Goroutine :: an internally sync lightweight thread of execution with *isolated
  mutable internal state* concurrently executed by the Go runtime with other
  goroutines. Goroutines are *non-preemptive*, but have *well-defined preemption
  points* (IO operations, system calls) when goroutines are suspended and
  resumed. A goroutine accepts parameters, but *return values are ignored*: use
  channels instead
  - Goroutines follow the *fork-join concurrency model* using channels for
    synchronization, are multiplexed over OS threads by the runtime-aware,
    software-defined, *userspace M:N scheduler* with fast context switching
  - Goroutines run in a *single address space*, start with a small
    *per-goroutine stack* that can grow, and take advantage of a low-latency
    concurrent GC
- Keep concurrent code within a scope of a sync function that *clearly defines
  lifetimes of goroutines*. Never start a goroutine without knowing how it will
  stop. There must be a way to signal a goroutine that it should stop

*** Channels

- Channel :: a first-class, named, typed, composable through ~select/case~
  *concurrency-safe bidirectional pipe* that provides sync and optionally async
  communication between multiple goroutines. Multiple goroutines can send and
  receive from a single channel, but each value will be received by exactly one
  goroutine. A channel is a *reference type* like a slice and a map. A channel
  orchestrates a transformation flow of values with *data ownership transfer*
  between concurrent goroutines, ensuring that only one goroutine has ownership
  on specific value at any point in time
  - *Unidirectional channel* a send-only src_go{ chan<- int } and a receive-only
    src_go{ <-chan int } channels *enforced at compile-time* mainly for function
    parameters and local variables. Bidirectional channels are implicitly
    converted to unidirectional channels. A receive-only channel cannot be
    closed
  - *Channel ownership* a goroutine that creates a channel src_go{ ch :=
    make(chan int) } and sends values over a channel has to close a channel
    src_go{ close(ch) }
  - *Share memory by communicating* over channels, do not communicate by sharing
    memory with mutexes
  - Receive from a closed channel immediately and continuously returns a zero
    value for the channel type
  - Send to or receive from a nil channel blocks forever
  - Send to a closed channel, close an already closed channel, close a nil
    channel panics
- Unbuffered channel :: (default, blocking, sync) src_go{ ch := make(chan int) }
  send blocks until receive, receive blocks until send. Only an unbuffered
  channel provides a *strong synchronization guarantee* and *delivery
  confirmation* to a sender. A receive from an unbuffered channel happens
  *before* a send completes: send start => receive complete => send complete
- Buffered channel :: (backpressure, async) src_go{ ch := make(chan int, 1) } an
  efficient *async in-memory queue* with *at most n non-blocking sends or
  receives*. A full channel blocks sending, an empty channel blocks receiving. A
  buffered send returns immediately and is *not confirmed to a sender*

*** select and context

- ~select~ :: enables *composition of channels* by efficiently and
  *sumltaneously sending and receiving* values from *multiple competing
  channels* in a *uniformly random* way to *avoid deadlocks*. ~select~ blocks on
  multiple channels and simultaneously and randomly evaluates each clause until
  the first operation completes on any of the composed channels or a ~default~
  *non-blocking* clause is executed immediately if present
- ~context~ :: a hierarchical, tree-like (context wrapping/derivation),
  *immutable data structure* that is used to provide an *explicit or
  timeout/deadline-based cancellation* from a parent goroutine of multiple child
  goroutines working on a shared context. A received context can be wrapped with
  new cancellation instructions and forwarded to children goroutines without
  affecting a parent goroutine (immutable context). It is very important to
  wrap/derive from a parent context that is forwarded to children, so
  *cancellations are propagated through the call stack*. When a context is
  canceled all derived contexts are automatically canceled. A context can also
  be used to forward request-scoped meta data (invisible dependencies problem)
  to children goroutines working on a shared context

#+BEGIN_SRC go
func contextCancelTimeout() {
  var wg sync.WaitGroup
  task := func(ctx context.Context) {
    defer wg.Done()
    for {
      select {
      // a channel is closed when a context is canceled
      case <- ctx.Done(): // immediately returns a zero value when closed
        switch ctx.Err() {
        case context.Canceled:
          fmt.Println("canceled")
        case context.DeadlineExceeded:
          fmt.Println("timeout")
        }
        return
      default: // non-blocking
        fmt.Println("working...")
        time.Sleep(100 * time.Millisecond)
      }
    }
  }
  // cancel context
  ctx, cancel := context.WithCancel(context.Background())
  // once created a cancellable context must be canceled
  defer cancel()
  wg.Add(1)
  go task(ctx)
  time.Sleep(300 * time.Millisecond)
  cancel() // further cancellations are ignored
  wg.Wait()
  // timeout context
  ctx, cancel2 := context.WithTimeout(
    context.Background(), 300 * time.Millisecond,
  )
  defer cancel2()
  wg.Add(1)
  go task(ctx)
  wg.Wait()
}
#+END_SRC

*** Mutex

- Mutex :: provides an exclusive read and write access (synchronization) to a
  resource/memory shared between multiple concurrent goroutines
- Critical section :: is a set of instructions that has to be executed without
  interruptions

#+BEGIN_SRC go
func counterMutex() {
  n := 100000
  var cnt int
  var mtx sync.Mutex // make a zero value useful
  var wg sync.WaitGroup
  wg.Add(2)
  go func() {
    defer wg.Done()
    for range n {
      mtx.Lock() // a single writer can hold a write lock, no readers
      cnt++ // write critical section
      mtx.Unlock()
    }
  }()
  go func() {
    defer wg.Done()
    for range n {
      mtx.Lock()
      cnt-- // read critical section
      mtx.Unlock()
    }
  }()
  wg.Wait()
  fmt.Println(cnt)
}
#+END_SRC

- Data race :: *unintended interleaving* of instructions from two non-atomic
  operations that concurrently modify the same data e.g. *two increments* (read,
  update, write) that results in *data corruption* when multiple goroutines
  access the same memory location simultaneously and at least one of them is
  writing. Solution: hardware atomic operations, mutex access synchronization,
  channel data ownership orchestration
- Race conditions :: *incorrect ordering* of two operations that concurrently
  modify the same data e.g. *two assignments* resulting in *data inconsistency*
  when a final result depends on the ordering of concurrent operations.
  Solution: channel data ownership orchestration
- Deadlock :: all goroutines are blocked waiting on one another. Solution:
  ~select/case~. Coffman conditions of a deadlock
  - *Mutual exclusion* a goroutine has an exclusive access to a shared resource
  - *Non-preemption* a shared resource can only be released by a holding
    goroutine
  - *Wait for condition* a goroutine holds a shared resource while waiting for
    another resource
  - *Circular wait* a goroutine waits on a chain of other goroutines that in
    turn wait on the first goroutine

#+BEGIN_SRC go
func deadlock() {
  in, out := make(chan int), make(chan int)
  go func() {
    <- in // blocking receive
    out <- 1
  }()
  <- out // blocking receive - deadlock!
  in <- 2
  select { // no deadlock, simultaneous and random order of cases
  case <- out:
  case in <- 2:
  }
}
#+END_SRC

- Livelock :: two or more goroutines operate, but *without making any progress*
  by continuously starting and cancelling operations because of the other
  goroutines
- Starvation :: a goroutine cannot get all resources needed to complete a task

*** WaitGroup

- WaitGroup :: a *concurrency-safe counter* that allows waiting for multiple
  goroutines to complete

#+BEGIN_SRC go
func waitGroup() {
  var wg sync.WaitGroup // make a zero value useful
  wg.Add(1) // increment a counter
  go func() {
    defer wg.Done() // decrement a counter
    time.Sleep(200 * time.Millisecond)
    fmt.Println("a")
  }()
  wg.Add(1)
  go func() {
    defer wg.Done()
    time.Sleep(100 * time.Millisecond)
    fmt.Println("b")
  }()
  wg.Wait() // block the main goroutine until a counter == 0
  fmt.Println("done") // b a done
}
#+END_SRC

*** Conditions

- Condition :: a goroutine A iteratively signals to a waiting goroutine B or
  broadcasts to multiple waiting goroutines B, C, D value updates vs delivery of
  values over a channel to a single goroutine. A condition uses a ~sync.Locker~
  to synchnonize access to a shared state between goroutines A and B, C, D

#+BEGIN_SRC go
func condBroadcast() {
  var balance int
  cnd := sync.NewCond(new(sync.Mutex))
  listen := func(goal int) {
    cnd.L.Lock()
    // critical section 1: wait for a condition
    for balance < goal { // exit a loop when a condition is met
      // listen for an update. Must be within a critical section
      // cnd.L.Unlock => wait for the next cnd.Broadcast => cnd.L.Lock
      cnd.Wait()
    }
    // critical section 2: a condition is met
    fmt.Printf("goal %v\n", balance)
    cnd.L.Unlock()
  }
  go listen(3)
  go listen(5)
  for i := 0; i < 7; i++ { // producer
    time.Sleep(100 * time.Millisecond)
    cnd.L.Lock()
    balance++ // critical section 2: update a shared state
    cnd.Broadcast() // broadcast an update to all listeners
    cnd.L.Unlock()
  }
}
#+END_SRC

** Testing

*** Testing tools

- Test *public behavior, what* using the *simple black box* testing
- Avoid testing private implementation details, how using the complex white box
  testing, mocks, and spies e.g. do not test private functions
- Stable tests are a *valuable software asset* as they define *what* a program
  is doing, while a more *varying code* defines *how* a program is done
- Property-based testing :: (vs conventional example-based testing) verifies
  domain *rules and invariants* on automatically generated *arbitrary input*
  src_go{ import "testing/quick" }
- Spy :: records the number of calls with call arguments, returned values, and
  errors
- Stub :: stateless static behavior for all requests carefully crafted for each
  test
- Mock :: stateful dynamic behavior on specific requests for controllable
  state + spy, carefully crafted for each test
- Fake :: stateful simplified implementation of a real dependency for all
  requests with decorators or stubs for triggering errors e.g. an in-memory DB.
  A single fake covers all tests for a dependency
- Test file :: ~file_test.go~, src_go{ import "testing" }
- Test function :: ~TestFunc(t *testing.T)~
- src_fish{ go test -v <package> -run <reTest> } selective testing
- src_fish{ go test -v -cover -coverprofile=<coverage.cov> } test with coverage
- src_fish{ go tool cover -html=<coverage.cov> } HTML coverage report
- ~t.Errorf()~ continues a test function and collects multiple errors
- ~t.Fatalf()~ exits a test functions and returns the first error

*** Before/after all/each, setup/teardown

#+BEGIN_SRC go
package main // has access also to private varaibles and functions
package main_test // test only public API
import (
  "testing"
  "os"
  "github.com/volodymyrprokopyuk/main" // test only public API
)
var arr []int // for before all
func TestMain(m *testing.M) {
  // * before all
  arr = []int{1, 2, 3, 4, 5}
  exitCode := m.Run() // run tests
  // * after all
  arr = arr[:0]
  os.Exit(exitCode)
}
func beforeEach(t *testing.T) []int {
  // * before each
  arr := []int{1, 2, 3, 4, 5}
  // * after each
  t.Cleanup(func() {
    arr = arr[:0]
  })
  return arr
}
func TestReduce(t *testing.T) {
  // * test setup
  arr := []int{1, 2, 3, 4, 5}
  // * test teardown
  defer func() {
    arr = arr[:0]
  }()
  // before/after each
  arr := beforeEach(t)
  // test both unexported and exported functions
  got := Reduce(arr, 0, func(a, b int) int { return a + b })
  // test only public API
  got := main.Reduce(arr, 0, func(a, b int) int { return a + b })
  exp := 15
  if got != exp {
    t.Errorf("Reduce: expected %v, got %v", exp, got)
  }
}
#+END_SRC

*** Test table

- Test table :: tests different input cases on the same code

#+BEGIN_SRC go
func TestTableReduce(t *testing.T) {
  cases := []struct {
    name string
    arr []int
    exp int
  }{
    {"empty slice", []int{}, 0},
    {"slice", []int{1, 2, 3}, 6},
  }
  for _, c := range cases {
    c := c // test closure accesses the right test case
    t.Run(c.name, func(t *testing.T) {
      t.Parallel() // run test cases in parallel
      got := Reduce(c.arr, 0, func(a, b int) int { return a + b })
      if got != c.exp {
        t.Errorf("Reduce: expected %v, got %v", c.exp, got)
      }
    })
  }
}
#+END_SRC

*** Benchmarking

- Benchmarking :: measures the time per operation and memory allocations per
  operation. By default benchmarks are run sequentially
- src_fish{ go test -v -bench=. -benchmem -benchtime=2s } benchmark with memory
  allocations

#+BEGIN_SRC go
var blackhole int
func BenchmarkReduce(b *testing.B) {
  for i := 0; i < b.N; i++ {
    blackhole = Reduce(arr, 0, func(a, b int) int { return a + b })
  }
}
#+END_SRC

** Style guide

*** Naming

- ~pkgname~ short, all lowercase package name
- ~pkg.Identifier()~ short, not repetitive name that uses a context and improves
  call site reading. Do not repeat a package name in a function name
- ~MaxLength, URLPath, UserID~ exported. ~maxLength, urlPath, userID~ unexported
- ~Counter()~ a getter. ~SetCounter()~ a setter
- Refactor long lines into separate statements. Do not split long lines

*** Variables

- Length of a variable is proportional to a scope (the smaller a scope, the
  shorter a variable) and is inversely proportional to a usage frequency (the
  more frequent usage, the shorter a variable)
- It is fine to reuse variables that are no longer needed e.g. reassign to a
  function parameter
- Equivalences
  - src_go{ var i int } and src_go{ i := 0 }
  - src_go{ new(File) } and src_go{ &File{} }
  - src_go{ make(map[string]int) } and src_go{ map[string]int{} }
  - src_go{ fmt.Errorf("oh") } and src_go{ errors.New("oh") }
- Prefer ~var i int~ over ~i := 0~ for a zero value initialization
- Prefer ~a := 1~ over ~var a = 1~ for a non-zero value initialization
- Prefer ~a = 1~ over ~a := 1~ to avoid shadowing in local nested scopes
- Prefer nil container src_go{ var arr []int } over an initialized empty
  container src_go{ var arr = []int{} }. Make the nil value useful src_go{ var
  wg sync.WaitGroup }

*** Interfaces

- Go interfaces generally belong to a consumer not to a provider. An interface
  should be discovered by a consumer, not imposed by a provider. Accept
  interfaces, return structs
- Value receiver = preserves immutability
  - A method operates on a copy of a receiver and does not modify the original
    receiver
  - Methods with value receivers can be called on pointers and values
- Pointer receiver = implies mutability. When in doubt use a pointer receiver
  - A method needs to modify a receiver
  - A receiver contains fields that cannot safely be copied e.g. sync.Mutex
  - A receiver is large
  - Methods with pointer receivers can only be called on pointers (addressable
    values)
- Make method of a type either all pointer methods or all value methods
- Verify interface compliance for custom types at compile time
  - Value type src_go{ var _ http.Handler = CustomHandler{} }
  - Pointer type src_go{ var _ http.Handler = (*CustomHandler)(nil) }

*** Error handling

- Handle errors first on the right src_go{ if err != nil { return } }. Push
  happy path processing to the bottom of a function on the left (without
  indentation)
- Handle type assertion failures src_go{ t, assert := a.(Type) }
- Prefer error over panic: use panic mostly in must-style functions e.g.
  ~MustCompile()~
- ~panic/recover~ is not an error handling strategy
- Use ~defer~ to clean up resources e.g. close files, unlock mutexes
- Call ~os.Exit()~ at most once only in ~main()~. All other functions should
  return errors to signal a failure or multiple exist scenarios. ~defer~
  functions are not executed when ~os.Exit()~ is called

*** Go proverbs

- Don't communicate by sharing memory (with mutexes), share memory by
  communicating (by sending messages through channels)
- Channels orchestrate (concurrent interactions), mutexes serialize (concurrent
  access to shared memory)
- The bigger the interface (Interface Segregation Principle), the weaker the
  abstraction (Dependency Inversion Principle)
- Make the zero value useful (do not impose unnecessary initialization)
- src_go{ type any interface{} } says nothing (about applicable operations to a
  type)
- Do not panic (explicitly return and check errors)
