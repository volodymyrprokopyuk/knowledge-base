* Go lang

** Type system

*** Primitive and composite types

| Primitive value types                                 |
|-------------------------------------------------------|
| ~bool~, ~byte = int8~, ~int = int64~, ~uint = uint64~ |
| ~float64~                                             |
| ~rune = int32~, ~string~                              |

| Composite reference types                          |
|----------------------------------------------------|
| src_go{ var arr [3]int } fixed-length array        |
| src_go{ var slc []int } slice = dynamic array      |
| src_go{ var htb map[string]int } map = hash table  |
| src_go{ var ch chan int } concurrency-safe channel |

- Comparable types ~a == b~ :: all primitive types, pointers, arrays, channels,
  structs of comparable types, interfaces. *Slices* and *maps* are /not
  comparable/: use custom ~Equal()~ implementation


- Type alias :: allows to attach different methods to the same underlying type.
  A type alias implements *nominal typing*

#+BEGIN_SRC go
type Year int // type alias
func (y Year) String() string {
  return fmt.Sprintf("Year %v", int(y))
}
year := Year(2024) // explicity type conversion
fmt.Println(year) // Year 2024
#+END_SRC

*** Constants and enumerations

- Typed constant :: compile-time declaration only for primitive types
  src_go{ const i int = 1 }
- Untyped constant :: compile-time named literal
  src_go{ const c = 1; var i int = c; var f float64 = c }
  - *Immutable values* at runtime: use a /call-by-value/ copy
  - *Mutable values* at runtime: use a /pointer/ to a value
- Enumeration :: a typed list of constants using ~iota~

#+BEGIN_SRC go
type BayanModel int
const (
  Nextra BayanModel = iota
  Omnia
  Selecta
  Prime
  Spectrum
)
fmt.Println(Nextra, Selecta, Spectrum) // 0, 2, 4
#+END_SRC

*** Variables and pointers

#+BEGIN_SRC go
var i, j int = 1, 2 // typed variables
var i, f = 1, 1.2 // default type for literals int, float64
var b, s, r = false, "ok", 'a' // type inference
var (
  // default initialization to zero value for primitive types
  b bool; i int; f float64; r rune; s string;
  // default initialization to nil for slice/map/chan, pointer/interface/func
  slc []int; htb map[string]int; ch chan int;
)
// short variable declaration: inferred in-function initialization
b, i, f, r, s := true, 1, 1.2, 'a', `ok`
#+END_SRC

- Pointer :: implies /mutable data/ vs a *call-by-value* copy that preserves
  /immutability/ of original data. Using pointers (implies expensive x10 heap
  allocation and GC) to avoid (extremely efficient self-cleaning on stack)
  copies is not necessarily faster. Minimize the on heap allocation of
  variables by reusing object from ~sync.Pool~
  - *Sharing up escapes to the heap*. All local variables referenced outside of
    a function body are allocated on the heap. Avoid returning pointers from a
    function and sending pointers to a channel
  - *Sharing down states on the stack*. Forward pointers to local variables to
    function calls

#+BEGIN_SRC go
var i int = 1
var p *int = &i // & address
i++; *p++ // * dereferencing
fmt.Println(i, *p) // 3, 3
#+END_SRC

*** Strings and runes

- String :: a length and a pointer to an immutable array of arbitrary bytes
  - *Charset* Unicode code points: to variable-length *encoding* UTF-8 (up to 4
    bytes)

#+BEGIN_SRC go
s := "Добро"
for i, b := range s {
  fmt.Printf("%d:%c ", i, b) // byte index: 0:Д 2:о 4:б 6:р 8:о
}
fmt.Println(s[:2]) // first 2 bytes: Д
for i, r := range []rune(s) {
  fmt.Printf("%d:%c ", i, r) // rune index: 0:Д 1:о 2:б 3:р 4:о
}
fmt.Println(string([]rune(s)[:2])) // first two runes: До
#+END_SRC

*** Arrays

- Array :: a fixed-length contiguous block of memory

#+BEGIN_SRC go
// automatic zero initialization
var a [3]int // 0, 0, 0
// explicit initialization
b, c := [3]int{}, [...]int{1, 2, 3} // 0, 0, 0; 1, 2, 3
// sparse array
d := [...]int{1, 2: 2, 4: 3} // 1, 0, 2, 0, 3
#+END_SRC

*** Slices

- Slice :: a /non-comparable/ *dynamic array*. A slice contains a pointer to an
  array, a length, and a capacity. Slices can provide /multiple views/ into a
  single array
  - *Full slice expression* ~slc[i:j:cap]~ limits side effects of appending by
    reallocating the underlying array when ~len == cap~

#+BEGIN_SRC go
// nil slice
var a []int // []
// increments length, dynamic reallocation
a = append(a, 1, 2) // 1, 2
// explicit initialization
b := []int{1, 2, 3} // 1, 2, 3
// sparse array
c := []int{1, 2: 2, 4: 3} // 1, 0, 2, 0, 3
// zero initialized slice with len == 3, cap == 3
d := make([]int, 3)
for i, v := range []int{1, 2, 3} {
  d[i] = v // 1, 2, 3
}
// empty slice with len == 0, cap == 3
e := make([]int, 0, 3)
for _, v := range []int{1, 2, 3} {
  e = append(e, v) // 1, 2, 3
}
arr := [...]int{1, 2, 3}
// array to slice: shared memory
f := arr[:] // 1, 2, 3
// array to slice: copy
g := make([]int, len(arr))
copy(g, arr[:]) // 1, 2, 3
// slice to array: copy
arr2 := [3]int(f) // 1, 2, 3
#+END_SRC

*** Maps

- Map :: a /non-comparable/ *hash table*. A map contains s pointer on an array
  of buckets, a length, and a capacity.

#+BEGIN_SRC go
// nil map
var a map[string]int
// initialized map
b := map[string]int{"a": 1, "b": 2}
// empty map with len == 0, initial cap == 3
c := make(map[string]int, 3)
c["a"] = 1
// key in map
if v, in := c["a"]; in {
  fmt.Println(v) // 1
}
for k, v := range b {
  fmt.Println(k, v) // a: 1, b: 2
}
// delete key
delete(c, "a")
#+END_SRC

*** Structures

- Structure :: a user-defined data type that implements *nominal typing*

#+BEGIN_SRC go
type Bayan struct {
  Model string
  Year int
}
// constructor function vs struct literal
func NewBayan(model string, year int) *Bayan {
  // local value is allocated on the heap
  // when its value is returned from a function
  return &Bayan{model, year}
}
// explicit field names
a := Bayan{Model: "Nextra", Year: 2020}
// positional field values
b := Bayan{"Omnia", 2021}
// anomymous struct, structural typing
var c Bayan = struct{Model string; Year int}{"Selecta", 2022}
// struct literal
p := &Bayan{Model: "Prime"} // Prime, 0
// constructor function
q := NewBayan("Spectrum", 2024)
// nil Bayan
s := new(Bayan)
fmt.Println(a, b, c, p, q, s)
#+END_SRC

- Struct embedding :: a *composition* of types where fields of embedded types
  are promoted to a containing type
  - *Composition*: an embedded type is a method receiver; a new type is not an
    embedded type
  - *Inheritance*: a subclass is a method receiver; a subclass can substitute a
    superclass

#+BEGIN_SRC go
type Product struct {
  Bayan // embedded fields without name
  Price float64
}
p := Product{Bayan{"Nextra", 2020}, 1.6e4}
// fields of an embedded type are promoted to a top-level containing type
fmt.Println(p.Model, p.Price, p.Bayan.Year)
#+END_SRC

** Flow control

*** if/else

- ~if/else~ :: allows /arbitrary conditions/ in each clause; each clause has its
  /own scope/
  - Align the happy path to the left; favor early return/break/continue
  - The happy path goes down, while edge cases are handled on the right

#+BEGIN_SRC go
if i := rand.Intn(10); i < 3 {
  fmt.Println(i, "low")
} else if i < 8 {
  fmt.Println(i, "mid")
} else {
  fmt.Println(i, "high")
}
#+END_SRC

*** for/range + break/continue [label]

- ~for/range~ :: provides a wide range of iteration algorithms
  - A controlled iteration with a start, end, and step
  - A loop with dynamic exit condition
  - A loop with unconditional first iteration
  - A loop over strings, arrays, slices, and maps

#+BEGIN_SRC go
// controlled iteration with start, end, and step
for i := 0; i < 3; i++ {
  fmt.Println(i) // 0, 1, 2
}
a := []int{1, 2, 3}
// multiple initialization
for i, l := 0, len(a); i < l; i++ {
  fmt.Println(a[i]) // 1, 2, 3
}
i := 0
// dynamic exit condition
for i < 3 {
  fmt.Println(i) // 0, 1, 2
  i++
}
i = 0
// unconditional first iteration
for {
  fmt.Println(i) // 0, 1, 2
  i++
  if i > 2 {
    break
  }
}
// iterate over strings, arrays, slices, maps
// range returns a copy values not suitable for update: use indexing
for i, v := range []int{1, 2, 3} {
  fmt.Printf("%d: %d\n", i, v) // 0: 1, 1: 2, 2: 3
}
// range expression evaluated once before a loop
a = []int{1, 2, 3}
for range a {
  a = append(a, 9) // 1, 2, 3, 9, 9, 9
}
#+END_SRC

*** switch/case + break label

- ~switch/case~ :: provides conditionals based on equality check or arbitrary
  conditions in each clause

#+BEGIN_SRC go
a := []string{"one", "eleven", "thousand"}
outer: for _, v := range a {
  // equality == check in each clause
  switch l := len(v); l {
  case 1, 2, 3:
    fmt.Println("small")
  case 4, 5, 6:
    fmt.Println("medium")
    break outer
  default:
    fmt.Println("large")
  }
}
for _, v := range a {
  // arbitrary condition in each clause
  switch l := len(v); {
  case l < 4:
    fmt.Println("small")
  case l < 7:
    fmt.Println("medium")
  default:
    fmt.Println("large")
  }
}
#+END_SRC

*** goto label

#+BEGIN_SRC go
for _, v := range []int{1, 2, 3} {
  if v == 2 {
    goto print
  }
  v *= 10
  print: fmt.Println(v) // 10, 2, 30
}
#+END_SRC

** Error handling

*** Error wrapping

- Error :: a type that signals an unexpected yet recoverable situation and
  implements the src_go{ type error interface { Error() string } } interface
  - *Sentinel error* an error value that signals an expected outcome e.g. EOF
  - *Error wrapping* builds a chain of error types that convey additional
    context
  - By returning an ~error~ interface a function can return different error
    types

#+BEGIN_SRC go
var ErrOh = errors.New("sentinel oh")
// custom error
type OhError struct {
  Msg string
}
// custom error must implement the error interface
func (e OhError) Error() string {
  return e.Msg
}
err := func() error {
  return ErrOh // sentinel error
  return OhError{"custom oh"} // custom error
}()
if errors.Is(err, ErrOh) {
  fmt.Println(err) // sentinel oh
}
if errors.As(err, &OhError{}) {
  fmt.Println(err) // custom oh
}
#+END_SRC

#+BEGIN_SRC go
// sentinel error
var ErrDivideByZero = errors.New("divide by zero")
func quoteRem(a, b int) (int, int, error) {
  if b == 0 {
    // return zero values for non-error return types
    return 0, 0, ErrDivideByZero
  }
  // return nil for the error return type
  return a / b, a % b, nil
}
// custom error type
type CustomError struct {
  Msg string
}
// implements the built-in error interface
func (ce CustomError) Error() string {
  return fmt.Sprintf("custom error: %v", ce.Msg)
}
// error wrapping
func wrapError(sentinel bool) error {
  if sentinel {
    // sentinel error: expected outcome
    return ErrDivideByZero
  }
  // error wrapping: additional error context
  return fmt.Errorf("wrapped error: %w", CustomError{"oh"})
}
err := wrapError(false)
if err != nil {
  // check for a sentinel error value in a wrapped chain of errors (==)
  if errors.Is(err, ErrDivideByZero) {
    fmt.Println("sentinel error:", err)
  }
  // check for a custom error type in a wrapped chain of errors (reflection)
  if errors.As(err, &CustomError{}) {
    fmt.Println("custom error:", err)
  }
}
#+END_SRC

*** panic/recover

- Panic :: signals termination of a program due to an unrecoverable situation. A
  ~panic~ unwinds a stack only to the top of the current goroutine, so a
  ~recover~ must be within a scope of the current goroutine
  - ~recover~ must be called only inside a ~defer~ as only defer functions are
    executed on panic
  - An application uses a recover to gracefully handle a shutdown
  - A library uses a recover to convert a panic into an error at a public API
    boundary

#+BEGIN_SRC go
func panicRecover() {
  defer func() {
    // call recover only in defer
    if msg := recover(); msg != nil {
      fmt.Println("panic:", msg)
    }
  }()
  panic("oh") // unrecoverable situation
}
panicRecover()
fmt.Println("continue") // panic: oh, continue
#+END_SRC

** Functions and methods

*** Functions

- Function :: all function parameters including pointers are call-by-value
  copies. A function allows multiple return values
  - *Named return values* mostly for documentation of function types and
    interfaces, and also to access return values in ~defer~
  - *Anonymous functions* (function literals) are closures

#+BEGIN_SRC go
// multiple return values
func quoteRem(a, b int) (int, int) {
  return a / b, a % b
}
q, r := quoteRem(5, 3) // 1, 2
// variadic parameters
func sum(vals ...int) int {
  sum := 0
  for _, v := range vals {
    sum += v
  }
  return sum
}
s := sum([]int{1, 2, 3}...) // 6
// function type
type Op func(a, b int) (res int)
// anonymous function: function literal
var sum Op = func(a, b int) int {
  return a + b
}
fmt.Println(sum(1, 2)) // 3
// anonymous function: closure
for _, v := range []int{1, 2, 3} {
  v := v // variable shadowing, new variable per iteration
  func() {
    // closes over an iteration-local variable
    fmt.Println(v) // 1, 2, 3
  }() // immediately invoked function literal
}
#+END_SRC

- ~defer~ :: defer closures are evaluated after function return in the reverse
  order. Defer receivers and arguments to defer closures are evaluated when
  declared, not when executed

#+BEGIN_SRC go
// evaluation of defer receivers and arguments
func evalDefer() {
  b := Bayan{"Nextra", 2020}
  // defer value receiver is evaluated when declared
  defer b.Print() // Bayan Nextra 2020
  b = Bayan{"Omnia", 2021}
  i := 1
  // defer arguments are evaluated when declared
  defer fmt.Println(i) // 1
  i = 2
}
// extending error context in defer reqiores named return values
func errorDefer() (err error) {
  err = fmt.Errorf("function oh")
  defer func() {
    if err != nil {
      // captures and wraps function error
      err = fmt.Errorf("defer oh: %w", err)
    }
  }()
  return err // defer oh: function oh
}
#+END_SRC

*** Methods

- Method :: a function that operates on a type value or a type pointer. A method
  can be invoked through a nil pointer receiver (make a zero value useful)
  - src_go{ function(receiver, args...) == receiver.method(args...) }
  - *Pointer receiver* ~(t *T)~ implies mutation
  - *Value receiver* ~(t T)~ a method operates on a copy of a type
  - Methods of an embedded type are promoted to a containing type

#+BEGIN_SRC go
type Bayan struct {
  Model string
  Year int
}
func (b Bayan) Print() {
  fmt.Printf("Bayan %v %v", b.Model, b.Year)
}
b := Bayan{"Nextra", 2020}
b.Print()
// method value closes over its instance
bPrint := b.Print
bPrint()
// method expression accepts a receiver as the first argument
bPrint2 := Bayan.Print
bPrint2(b)
#+END_SRC

** Interfaces

- Interface :: an abstract type that defines common behavior across distinct
  concrete types. An interface implements type-safe *structural typing* when a
  method set of a concrete type including promoted methods from embedded types
  fully covers all methods defined in an interface. An interface consists of
  - A *static type* an abstract interface type
  - A *dynamic type* concrete value type that implements an interface
  - *Dependency inversion principle* rely on an abstraction, not an
    implementation
  - *Interface segregation principle* the bigger the interface, the weaker the
    abstraction. Abstractions should be discovered, not created. Do not force an
    interface on a producer side: let a consumer discover the right abstractions
    with a minimal set of methods
  - *Robustness principle* accept interfaces (flexible input), return structs
    (compliant output)
  - *Type assertion* ~v.(Type)~ is applied to an interface at runtime
  - *Type conversion* ~Type(v)~ is applied to a concrete type at compile-time

#+BEGIN_SRC go
type Printer interface {
  Print()
}
type Int int
// a type just implements methods
// that can be used individually or as part of an interface
// a type is totally unaware of any interfaces
func (i Int) Print() {
  fmt.Println("Int", i)
}
type Flo float64
func (f Flo) Print() {
  fmt.Println("Flo", f)
}
// only a client specifies a required interface
vals := []Printer{Int(1), Flo(1.2)}
// process incompatible types through a uniform interface
for _, v := range vals {
  v.Print() // Int 1, Flo 1.2
}
// type assertion to access a dynamic type of an interface
var p Printer = Int(1) // type conversion
if i, is := p.(Int); is { // type assertion
  i.Print() // Int 1
}
// type switch to access a dynamic type of an interface
for _, v := range vals {
  switch v.(type) {
  case Int:
    fmt.Print("Integer ")
    v.Print() // Integer Int 1
  case Flo:
    fmt.Print("Float ")
    v.Print() // Float Flo 1.2
  }
}
#+END_SRC

- A function can implement a one-method interface

#+BEGIN_SRC go
// one-method interface
type Logger interface {
  Log(msg string)
}
// function type
type LogFunc func(msg string)
// function type implements a one-method interface
func (lf LogFunc) Log(msg string) {
  lf(msg)
}
// log function
func log(msg string) {
  fmt.Println(msg)
}
// log function == function type == one-method interface
var logger Logger = LogFunc(log)
logger.Log("ok") // ok
#+END_SRC

- Interface embedding :: a composition of abstract types: a containing type
  automatically implements all interfaces implemented by embedded types

#+BEGIN_SRC go
type Negator interface {
  Printer // embedded interface
  Neg()
}
func (i *Int) Neg() {
  ,*i = -*i
}
func (f *Flo) Neg() {
  ,*f = -*f
}
i, f := Int(1), Flo(1.2)
vals := []Negator{&i, &f}
for _, v := range vals {
  v.Neg()
  v.Print() // Int -1, Flo -1.2
}
#+END_SRC

** Generics

- Generics :: compile-time automatic generation of type-safe structures,
  functions, and methods
- Generic function :: has type parameters for input arguments and return values

#+BEGIN_SRC go
func Reduce[T, U any](slc []T, i U, acc func(v T, a U) U) U {
  var out U = i
  for _, v := range slc {
    out = acc(v, out)
  }
  return out
}
slc := []int{1, 2, 3, 4, 5}
Reduce(slc, 0, func(v, acc int) int { return v + acc }) // 15

// comparable types support ==, !=, but not <, <=, >, >=
// slice, map, func are not comparable
func Contains[T comparable](slc []T, val T) bool {
  for _, v := range slc {
    if v == val {
      return true
    }
  }
  return false
}
slc := []int{1, 2, 3}
Contains(slc, 2); Contains(slc, 4) // true, false
#+END_SRC

- Type elements and type terms :: type elements define operators supported by a
  type parameter. Supported operators are the intersection of operators from all
  type terms. Type terms match exactly, use =~= to match derived types. Type
  terms can be built-in types, arrays, slices, maps, channels, structs, and
  functions

#+BEGIN_SRC go
func Min[T ~int | ~string](a, b T) T {
  if a < b {
    return a
  }
  return b
}
Min(1, 2), Min("b", "a") // 1, a
#+END_SRC

- Generic struct :: has type parameters for its fields and methods

#+BEGIN_SRC go
type Stack[T any] struct {
  slc []T
}
func (s *Stack[T]) Push(val T) {
  s.slc = append(s.slc, val)
}
func (s *Stack[T]) Pop() (T, bool) {
  var val T
  l := len(s.slc)
  if l == 0 {
    return val, false
  }
  val = s.slc[l - 1]
  s.slc = s.slc[:l - 1]
  return val, true
}
var stk Stack[int]
stk.Push(1); stk.Push(2); stk.Push(3)
for val, nonEmpty := stk.Pop(); nonEmpty; {
  fmt.Println(val) // 3, 2, 1
  val, nonEmpty = stk.Pop()
}
#+END_SRC

- Type constants :: =T any= (unconstrained), =T comparable= (==, !=),
  =T ~ind | ~string= (<, <=, >,>=), =interface= (custom operations)

#+BEGIN_SRC go
// interface with type elements, supports <, <=, >, >=
type Cmp interface {
  ~int | ~string
}
// any interface can be used as a type constraint
func Compare[T Cmp](a, b T) int {
  if a < b {
    return -1
  }
  if a > b {
    return 1
  }
  return 0
}

type Node[T Cmp] struct {
  value T
  left, right *Node[T]
}
func (n *Node[T]) Insert(val T) *Node[T] {
  if n == nil {
    return &Node[T]{value: val}
  }
  switch cmp := Compare(val, n.value); {
  case cmp < 0:
    n.left = n.left.Insert(val)
  case cmp > 0:
    n.right = n.right.Insert(val)
  }
  return n
}
func (n *Node[T]) InOrder(f func (val T)) {
  if n != nil {
    n.left.InOrder(f)
    f(n.value)
    n.right.InOrder(f)
  }
}
var n *Node[int]
n = n.Insert(1); n = n.Insert(3); n = n.Insert(2) n = n.Insert(4)
n.InOrder(func (val int) {
  fmt.Printf("%v ", val) // 1, 2, 3, 4
})
#+END_SRC

** Packages and modules

- Package :: a set of types and functions defined in multiple files under a
  package directory. One-word all-lowercase package name should match a package
  directory. Every source file in a package directory must have the same package
  name src_go{ package pkgname }. Top-level Capitalized identifiers are exported
  from a package. Merge packages or create a new common package to resolve
  circular dependencies
  - Import a package src_go{ import "scm/user/mod/pkgdir" }
  - Import alias src_go{ import pkgname "scm/user/mod/pkgdir" }
  - Access an identifier src_go{ pkgname.Identifier }
- Module :: a unit of versioning identified by a repository path
  ~"scm/user/mod"~. A module represents either
  - *Library* of /importable packages/ src_fish{ go get ... } or
  - *Application* of /executable commands/ src_fish{ go install ... }
    src_go{ package main; func main { ... } }
  - Initialize a module src_fish{ go mod init scm/user/mod }. The ~go.mod~
    defines the current module, a supported Go version, and dependency modules
  - Update module dependencies src_fish{ go get -u ./...; go mod tidy }
  - Build and run a module during development src_fish{ go run ... }
  - Build a module src_fish{ go build }
  - Static code analysis
    - src_fish{ go install honnef.co/go/tools/cmd/staticcheck@latest }
      src_fish{ staticcheck ./... }
    - src_fish{ go install github.com/mgechev/revive@latest }
      src_fish{ revive ./... }
    - src_fish{ yay -S golangci-lint }
      src_fish{ golangci-lint run }

** Concurrency

- Concurrency :: a *structure* of code to solve a problem with sync steps that
  can be run in parallel
- Parallelism :: *execution* of independent sequences of instructions
- CSP (Communicating Sequential Processes) :: (more generic and flexible) a
  randevouz-based system within a single node where anonymous goroutines send
  and receive values over channels without having to specify the identity of a
  receiver. CSP puts focus on first-class channels and synchronization
- Actor model :: (more specific and complex) a distributed system of named
  actors where actors send and receive messages by specifying the identity of a
  recipient. An actor has an untyped mailbox and maintains an internal mutable
  state. Actors are combined in a fault-tolerant supervision hierarchies

*** Goroutines

- Goroutine :: internally sync lightweight thread concurrently executed by the
  Go runtime. A goroutine has well-defined preemption points (IO, system call)
  when a goroutine can be suspended and resumed. A goroutine accepts parameters,
  however return values are ignore
  - Goroutines follows the fork-join concurrency model, are multiplexed over OS
    threads by a runtime-aware software-defined M:N scheduler with fast context
    switching
  - Goroutines run in a single address space, start with small stack that can
    grow, and take advantage of a low-latency concurrent GC

*** Channels

- Channel :: a first-class, concurrency-safe, composable through ~select/case~
  *bidirectional pipe* that provides sync and async communication between
  goroutines. Multiple goroutines can send and receive from the same channel,
  but each value will be received by exactly one goroutine. A channel is a
  reference type like a slice and a map
  - *Unidirectional channel* a send-only src_go{ chan<- int } and a receive-only
    src_go{ <-chan int } channels enforced at compile-time mainly for function
    parameters and local variables. Bidirectional channels are implicitly
    converted to unidirectional channels. A receive-only channel cannot be
    closed
  - *Channel ownership* a goroutine that creates, sends, and closes a channel
  - *Share memory by communicating*, do not communicate by sharing memory
  - Receive from a closed channel immediately returns a zero value for a channel
    type
  - Send or receive from a nil channel blocks forever
  - Send to a closed channel, close a nil channel, close an already closed
    channel panics
- Unbuffered channel :: (blocking, sync) src_go{ ch := make(chan int) } send
  blocks until receive, receive blocks until send. Only an unbuffered channel
  provides a strong synchronization guarantee and delivery confirmation to a
  sender. A receive from an unbuffered channel happens /before/ a send
  completes: send => receive => send complete
- Buffered channel :: (backpressure, async) src_go{ ch := make(chan int, 1) } an
  efficient async in-memory queue with at most n non-blocking sends or receives.
  A full channel blocks sending, an empty channel blocks receiving. A buffered
  send returns immediately and is not confirmed to a sender

*** select and context

- ~select~ :: enables composition of channels by efficiently and sumltaneously
  sending and receiving values from multiple competing channels in a uniformly
  random way to avoid deadlocks. ~select~ blocks on multiple channels and
  simultaneously evaluates each clause until the first operation completes on
  any of the channels or a non-blocking ~default~ that is executed immediately
  if present
- ~context~ :: a hierarchical (context wrapping), immutable data structure that
  is used to provide an explicit or timeout/deadline-based cancellation from a
  parent goroutine of multiple child goroutines working on a shared context. A
  received context can be wrapped with new cancellation instructions and
  forwarded to children goroutines without affecting a parent goroutine. A
  context can also be used to forward request-scoped meta data (invisible
  dependencies) to children goroutines working on a shared context

#+BEGIN_SRC go
func ctxCancelTimeout() {
  var wg sync.WaitGroup
  task := func(ctx context.Context) {
    defer wg.Done()
    for {
      select {
      // a channel is closed when a context is cancelled
      case <- ctx.Done(): // immediately returns a zero value when closed
        if ctx.Err() == context.Canceled {
          fmt.Println("canceled")
        }
        if ctx.Err() == context.DeadlineExceeded {
          fmt.Println("timeout")
        }
        return
      default:
        fmt.Println("working...")
        time.Sleep(100 * time.Millisecond)
      }
    }
  }
  // cancel context
  ctx, cancel := context.WithCancel(context.Background())
  // once created a cancellable context must be cancelled
  defer cancel()
  wg.Add(1)
  go task(ctx)
  time.Sleep(300 * time.Millisecond)
  cancel() // further cancellations are ignored
  wg.Wait()
  // timeout context
  ctx, cancel2 := context.WithTimeout(
    context.Background(), 300 * time.Millisecond,
  )
  defer cancel2()
  wg.Add(1)
  go task(ctx)
  wg.Wait()
}
#+END_SRC

*** Mutex

- Mutex :: provides an exclusive access (synchronization) to a shared resource
  (critical section) between independent goroutines executed in parallel

#+BEGIN_SRC go
func rwMutex() {
  var value int
  var mu sync.RWMutex // make a zero value useful
  writeShared := func (val int) {
    mu.Lock() // a single writer can hold a write lock, no readers
    defer mu.Unlock()
    value = val // write critical section
  }
  readShared := func() int {
    mu.RLock() // multiple readers can hold a read lock, no writer
    defer mu.RUnlock()
    return value // read critical section
  }
  var wg sync.WaitGroup
  wg.Add(2)
  go func() {
    defer wg.Done()
    writeShared(1)
  }()
  go func() {
    defer wg.Done()
    time.Sleep(1 * time.Millisecond)
    fmt.Println(readShared()) // 1
  }()
  wg.Wait()
}
#+END_SRC

- Channel :: orchestrates a transformation flow of values with ownership
  transfer between concurrent goroutines, ensuring that only one goroutine has
  ownership on specific value at any point in time
- Data race :: interleaving of instructions operating on the same data from two
  operations e.g. two increments (read, update, write) resulting in data
  inconsistency or invalid data when multiple goroutines access the same memory
  location simultaneously and at least one of them is writing. Solution: atomic
  operations, mutex, channel
- Race conditions :: incorrect ordering of two operations modifying the same
  data e.g. two assignments resulting in data inconsistency when a final result
  depends on the ordering of concurrent operations. Solution: channel
- Deadlock :: all goroutines are blocked waiting on one another. Solution:
  ~select~. Coffman conditions of a deadlock
  - *Mutual exclusion* a goroutine has exclusive rights on a shared resource
  - *Wait for condition* a goroutine holds a shared resource while waiting for
    another resource
  - *No preemption* a shared resource can only be realeaded by a holding
    goroutine
  - *Circular wait* a goroutine waits on a chain of other goroutines that in
    turn wait on the first goroutine

#+BEGIN_SRC go
func deadlock() {
  in, out := make(chan int), make(chan int)
  go func() {
    <- in // blocking receive
    out <- 1
  }()
  <- out // blocking receive - deadlock!
  in <- 2
  select { // no deadlock, random order of cases
  case <- out:
  case in <- 2:
  }
}
#+END_SRC

- Livelock :: two or more goroutines operate, but without making any progress by
  continuously starting and cancelling operation because of the other goroutine
- Starvation :: a goroutine cannot get all resources needed to complete a task

*** WaitGroup

- WaitGroup :: a concurrency safe counter that allows waiting for multiple
  goroutines to complete

#+BEGIN_SRC go
func waitGroup() {
  var wg sync.WaitGroup // make a zero value useful
  wg.Add(1) // increment a gor counter outside of a tracking gor
  go func() {
    defer wg.Done() // decrement a gor counter
    time.Sleep(200 * time.Millisecond)
    fmt.Println("a")
  }()
  wg.Add(1)
  go func() {
    defer wg.Done()
    time.Sleep(100 * time.Millisecond)
    fmt.Println("b")
  }()
  wg.Wait() // block a gor until a counter == 0
  fmt.Println("done")
}
#+END_SRC

*** Conditions

- Condition :: provides a continuous broadcast of values to multiple waiting
  goroutines vs channel delivery of values to a single goroutine. A condition
  uses a ~sync.Locker~ to prevent data races

#+BEGIN_SRC go
func condBroadcast() {
  balance := 0
  cond := sync.NewCond(&sync.Mutex{})
  listen := func(goal int) {
    cond.L.Lock()
    defer cond.L.Unlock()
    // critical section 1: wait for a condition
    for balance < goal { // exit a loop when a condition is met
      // listen for an update. Must be within a critical section
      cond.Wait() // .L.Unlock => wait for the next .Broadcast => .L.Lock
    }
    // critical section 2: a condition is met
    fmt.Println("goal", balance)
  }
  go listen(3)
  go listen(5)
  for i := 0; i < 7; i++ { // producer
    time.Sleep(100 * time.Millisecond)
    cond.L.Lock()
    balance++
    cond.L.Unlock()
    cond.Broadcast() // broadcast an update to all listeners
  }
}
#+END_SRC

** Testing

- Test with coverage src_fish{ go test -v -coverprofile=coverage.cov }
- HTML coverage report src_fish{ go tool cover -html=coverage.cov }
- ~t.Errorf()~ continues a test function and collects multiple errors
- ~t.Fatalf()~ exists a test functions and returns the first error
- Testing of unexported (implementation) vs exported functions (interface)

#+BEGIN_SRC go
package main
package main_test // test only public API
import (
  "testing"
  "os"
  "github.com/volodymyrprokopyuk/main" // test only public API
)
var arr []int
func TestMain(m *testing.M) {
  // * before all
  arr = []int{1, 2, 3, 4, 5}
  exitCode := m.Run() // run tests
  // * after all
  arr = arr[:0]
  os.Exit(exitCode)
}
func beforeEach(t *testing.T) []int {
  // * before each
  arr := []int{1, 2, 3, 4, 5}
  // * after each
  t.Cleanup(func() {
    arr = arr[:0]
  })
  return arr
}
func TestReduce(t *testing.T) {
  // test setup
  arr := []int{1, 2, 3, 4, 5}
  // sets teardown
  defer func() {
    arr = arr[:0]
  }()
  // before/after each
  arr := beforeEach(t)
  // test both unexported and exported functions
  res := Reduce(arr, 0, func(v, i int) int { return v + i })
  // test only public API
  res := main.Reduce(arr, 0, func(v, i int) int { return v + i })
  exp := 15
  if res != exp {
    t.Errorf("Reduce: expected %v, got %v", exp, res)
  }
}
#+END_SRC

- Test table :: tests different inputs on the same code

#+BEGIN_SRC go
func TestTableReduce(t *testing.T) {
  cases := []struct {
    name string
    arr []int
    exp int
  }{
    {"empty slice", []int{}, 0},
    {"slice", []int{1, 2, 3}, 6},
  }
  for _, c := range cases {
    c := c // test closure accesses the right test case
    t.Run(c.name, func(t *testing.T) {
      t.Parallel() // run the test in parallel
      res := Reduce(c.arr, 0, func(v, i int) int { return v + i })
      if res != c.exp {
        t.Errorf("Reduce: expected %v, got %v", c.exp, res)
      }
    })
  }
}
#+END_SRC

- Benchmarking :: measures time per operation and memory allocations per
  operation
  - Benchmark with memory allocations
    src_fish{ go test -v -bench=. -benchmem -benchtime=2s }

#+BEGIN_SRC go
var blackhole int
func BenchmarkReduce(b *testing.B) {
  for i := 0; i < b.N; i++ {
    blackhole = Reduce(arr, 0, func(v, i int) int { return v + i })
  }
}
#+END_SRC
