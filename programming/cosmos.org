* Cosmos

** Cosmos SDK

- Cosmos SDK :: a modular capability-based framework for building from scratch
  application-specific multi-asset public Proof-of-Stake PoS and permissioned
  Proof-of-Authority PoA custom blockchains that interoperate with other
  blockchains. Cosmos SDK facilitates development of replicated deterministic
  state machines on top of CometBFT
- Application-specific blockchain :: a blockchain customized to operate a single
  application vs limited interpreted Solidity smart contracts competing on a
  shared EVM virtual machine
- Sovereignty :: application developers have full control over both an
  application state machine and an application-specific blockchain (consensus,
  networking)
- Full-node client :: a daemon that runs a CometBFT instance and maintains an
  application state machine by connecting to CometBFT consensus through ABCI

** CometBFT

- Replicated deterministic state machine :: a fault-tolerant distributed service
  that coordinates client interactions with at least three replicated servers to
  handle at most one independent server failure (n failures can be handled with
  2n + 1 replicas)
  - State machine :: a tuple of internal states with an initial state, external
    inputs, resulting outputs; a transition function: input, state => new state;
    an output function: input, state => output
  - Byzantine failure :: a replica sends different values to different peers for
    the same input and state. 2n + 1 replicas are required to handle a Byzantine
    failure with message signatures, or 3n + 1 without message signatures
- CometBFT :: an application-agnostic BFT consensus engine that automatically
  replicates an application state machine defined with Cosmos SDK. CometBFT
  provides networking and consensus, while Cosmos SDK provides an application
  state machine. CometBFT provides consensus on ordering of opaque transactions
  and propagates transactions to validators that add blocks of transactions to a
  blockchain
- Validator :: more than 2/3 of validators must sign a prevote and a precommit
  of a block to be considered valid. All transactions in a block are valid. An
  validator is randomly chosen to be a proposer for the next block

** ABCI

- Application Blockchain Interface ABCI :: a Cosmos SDK state machine is
  connected to a pluggable CometBFT consensus engine through an ABCI that can be
  wrapped by any programming language to develop a state machine using different
  designs e.g. validation, storage and libraries e.g. cryptography
  - CheckTx :: a client sends a TX to CometBFT which forwards a TX to the app
    CheckTX for validation. If valid a TX is added to a CometBFT mempool and
    relayed to peers
  - DeliverTX :: a proposer sends a valid block to CometBFT which forwards TXs
    in order to the app DeliverTX for execution. Each transaction contains one
    or more messages
- Core application :: Cosmos SDK ~baseapp~ implements all ABCI methods, extracts
  messages from transactions relayed by CometBFT, and routes messages to
  appropriate application modules. A core application contains a reference to a
  ~baseapp~, a list of store keys, a list of module ~keepers~, a reference to an
  ~appCodec~ for serialization and deserialization of state in module store, a
  reference to a module manager with a list of application modules, module
  invariants evaluated at the end of each block
- Module :: a nested state machine within an application state machine. An
  application combines a collection of interoperable modules. Each module
  handles a subset of state and has its own message processor and key-value
  store within a multistore. Modules are mediated by a module manager and
  interact with each other through keepers. Each module implements a message
  service for processing messages and a query service implemented by keepers to
  access a module store. Each module defines transactions and queries in form of
  CLI commands for local users, gRPC methods for external services, and REST
  endpoints through a gRPC gateway to be exposed through application interfaces
- Keeper :: instead of having each module to keep an ACL for other modules, each
  module implements a ~keeper~ that, when passed to other modules, grants a
  predefined set of read-write capabilities over a key-value store of a module.
  All access to a module store happens through keepers. Only keepers hold keys
  to a module store
