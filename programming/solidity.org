* Solidity

** Types

*** Value types

- Value types :: The value types are always *passed by value* as function
  arguments and in the assignment. The value types are *always stored on the
  stack*, hence the declarations of value types do not specify the data
  location. The only exception are state variables of value types marked with
  the =storage= data location. The value types can also be marked as =transient=
  cheaper than storage with the transaction lifetime, =constant= compile-time
  without memory allocation, or =immutable= construction time with memory
  allocation
- Default value :: Declared, but not initialized variables automatically get
  assigned the type-specific default value whose byte representation is *all
  zeros*. Undefined or null values are not possible in Solidity
- Arbitrary precision arithmetic on number literals :: The number literals
  retain the arbitrary precision until they are converted into a specific value
  type. Computations do not overflow nor underflow when performed in number
  literals. Most operands produce a literal expression when applied to literals.
  The division of literals results in the fractional values of the arbitrary
  precision. The division of integers rounds towards zero
- Checked arithmetic operations :: All arithmetic operations are checked by
  default and revert on an underflow or an overflow. ~unchecked { ... }~
  disables the arithmetic checks ans saves gas
- Ether units :: Numbers can have the =wei=, the =gwei=, and the =ether= suffix
  to identify the ether value. Numbers without a suffix are assumed to be in
  =wei=
| Ether unit | Ether value             |
| =1 wei=    | =1e-18 ether=           |
| =1 gwei=   | =1e-9 ether=, =1e9 wei= |
| =1 ether=  | =1e18 wei=, =1e9 gwei=  |
- Address :: Identifies an external address or a contract address. Prefer a
  contract reference src_solidity{ Contract c; } over a contract address with a
  cast src_solidity{ address c; }
- Payable address :: An external address or a contract address with a
  =receive()= function or a =payable fallback= function that accepts Ether
- Payable function :: A function that receives ether must be payable
- User-defined value type :: A user-defined value type creates the *zero-cost
  abstraction* over the underlying built-in value type. The user-defined value
  type has neither operators nor attached functions, only explicit conversion to
  and from the underlying value type is supported through the =wrap()= and
  =unwrap()= functions

| Value type                           | Operators and functions                 |
|--------------------------------------+-----------------------------------------|
| =bool=, =true=, =false=              | ~!, &&, ¦¦, ==, !=~                     |
| ~int = int256~, ~uint = uint256~     | ~<, <=, >=, >, ==, !=~                  |
|                                      | =~, &, ¦, ^, <<, >>=                    |
|                                      | ~+, -, *, /, %, **~                     |
|                                      | ~type(int).min, type(uint).max~         |
| ~fixed = fixed128x18~                | Fixed point number                      |
| ~ufixed = ufixed128x18~              | with variable precision                 |
| =address=                            | =0x123..abc= (20 bytes)                 |
| =address payable=                    | =payable(address).balance=              |
|                                      | =transfer()=, =send()=                  |
| =bytes1= .. =bytes32=                | Fixed padded array up to 32 bytes       |
|                                      | ~<, <=, >=, >, ==, !=~                  |
|                                      | =~, &, ¦, ^, <<, >>=                    |
|                                      | ~arr[i], arr.length~                    |
| ="string"=, =unicode"string"=        | ASCII and Unicode strings               |
| =hex"1a2b"=                          | Hex literal                             |
| ~enum State { Default, Start, End }~ | ~type(State).min~, ~type(State).max~    |
|                                      | ~state == State.Start~, ~delete state;~ |
| ~type Year is uint;~                 | ~Year.wrap(2024)~, ~Year.unwarp(year)~  |

*** Reference types

- Reference types :: The reference type defines a shared memory location
  accessible through multiple different reference names. The reference data
  types are =array=, =bytes=, =stirng=, =mapping=, and =struct=

**** Arrays

- Fixed array :: Each element of the fixed array ~T[k] arr;~ is initialized with
  the default value for the element type =T=. The fixed array cannot be assigned
  to a dynamic array. Fixed arrays of different sizes cannot be converted into
  each other
- Dynamic array :: Each element of the dynamic array ~T[] arr;~ is initialized
  with the default value for the element type =T=. The =storage= dynamic array
  automatically grows as elements are added to the array. The =memory= dynamic
  array does not grow. The notation is reversed e.g. ~T[][4]~ is the fixed array
  of 4 dynamic arrays. The element access is in the opposite direction to the
  declaration e.g. ~t[0][1]~ is the first element of the second dynamic array
- Array literal :: The type of the array literal is the type of the first
  element with all other elements implicitly convertible to the type of the
  first element
- Array slice :: The array slice represents a view on the array e.g.
  ~arr[start:end]~
  #+BEGIN_SRC solidity
uint[4] memory arr; // initialized with default values
arr[0] = 10;
uint[] memory arr = new uint[](4); // memory dynamic array does not grow
uint[] storage arr = [1, 2, 3]; // explicit initialization
arr.push(4); // only storage dynamic arrays grow automatically
if (arr.length > 0) {
  delete arr[0]; // reset the first element to the default value
  arr.pop(); // remove the last element
  delete arr; // reset the array to a new empty array
}
  #+END_SRC

**** Bytes and string

- Bytes array :: The =bytes= is a special type of array with *packed data* for
  storing *binary data*. The =bytes1[]= adds padding to each array element.
  Prefer a fixed array of =bytes1= .. =bytes32= over a dynamic array =bytes=.
  Bytes concatenation ~bytes.concat(b1, b2)~
- String array :: The =string= is equivalent to =bytes= for *Unicode*, but does
  not allow the length and the index access. String concatenation
  ~string.concat(s1, s2)~
  #+BEGIN_SRC solidity
// Comparison of strings
keccak256(abi.encodePacked(s1)) == keccak256(abi.encodePacked(s2))
// Low-level bytes manipulation, not Unicode code points
bytes(s).length; bytes(s)[k] = value;
  #+END_SRC

**** Mapping

- Mapping :: The ~mapping(keyType => valueType)~ stores values of any, but a
  single type under the keccak256 hash of the key type. Mappings can be nested.
  The key value is not stored in the mapping, hence keys cannot be enumerated,
  and the key must be know in order to access the value. The default value is
  returned for unset keys. The mapping can have only =storage= data location,
  hence mappings are used for state variables and as references to passed state
  variables in functions
- Delete :: The =delete= operator assigns the default value to a variable, an
  array position, a mapping slot, or a struct field. The delete operator assigns
  an empty fixed or dynamic array to an array variable. The delete operator has
  no effect on mappings, unless the delete operator is applied to a specific key
  within the mapping
  #+BEGIN_SRC solidity
mapping(address => uint) balances;
balances[acc] = 1; // set value for the key
if (balances[acc] > 0) {
  delete balances[acc]; // reset the key with the default value
}
  #+END_SRC

**** Struct

- Struct :: The =struct= defines a new user-defined type. Arrays and mappings
  can have structs and vice versa. Recursive structs are not supported

| Reference type          | Fields and functions                                 |
| ~T[k]~, ~T[]~           | =arr.length=, ~arr[i]~, ~arr.push(v);~, ~arr.pop();~ |
|                         | ~delete arr;~, ~delete arr[k];~                      |
| ~mapping(key => vlaue)~ | ~map[key] = value;~, ~delete map[key];~              |
| ~struct A { uint a; }~  | ~A a = A(1);~, ~A a = A({a: 1});~, ~A a; a.a = 1;~   |
|                         | ~delete a;~, ~delete a.a;~                           |

** Variables

*** Variable types

- Local variable :: The local variable is declared and used within the scope of
  a function. The local variable is not stored on the blockchain
- Storage variable :: The storage variable is defined and used within the scope
  of a contract. The storage variable is stored on the blockchain. The storage
  variable cannot be external. A write to a storage variable must be within a
  transaction. A read from a storage variable does not require a transaction
- Global variable :: The global variables are implicitly provided by the EVM
  e.g. =msg.sender=, =msg.value=

*** Storage and memory

- Data location :: The data location specifies where the declared variables are
  allocated. The data location =storage=, =transient=, =calldata=, and =memory=
  must be specified for declarations of reference data types. The =storage= data
  location for state variables within a contract can be omitted
- Permanent storage :: The =storage= data location is a per contract expensive
  persistent key-value store in the form of ~mapping(bytes => bytes)~ stored on
  the blockchain
- Transient storage :: The =transient= data location is less expensive then the
  storage data location and is reset at the end of each transaction
- Calldata :: The =calldata= data location stores function arguments in a
  read-only, volatile, memory-like data location that avoids unnecessary copies
  of data to save gas
- Memory :: The memory is accessible within the scope of a function, and
  provides 32-bytes reads, and 1-byte and 32-bytes writes
- Stack :: The EVM is a stack-based machine, not a register-based machine. All
  computations are performed on the stack with max 1024 32-bytes words

*** State variables

- State variables :: The state variables are either permanently stored in the
  contract storage or temporarily stored in the transient storage that is reset
  at the end of each transaction
- State variable visibility :: The visibility of state variables only prevents
  the derived or external contracts from reading or writing state variables, but
  all state is publicly available for reading on the blockchain
  - Private :: A =private= state variable is only accessible to the defining
    contract and is not accessible to the derived contracts
  - Internal :: An =internal= state variable (default visibility) is accessible
    to the defining contract and to the derived contracts
  - Public :: A =public= state variable is read-only accessible to other
    contracts through the automatically generated getters. Public state
    variables allow direct access via the direct reference =x= or external
    access through the getters via =this.x=. A getter view function is
    automatically generated for every public state variable
    #+BEGIN_SRC solidity
contract Contract {
  address public owner; // automatically generates
  function owner() external view returns (address) {
    return owner;
  }
  uint[] public values; // automatically generats
  function values(uint i) external view returns (uint) {
    return values[i];
  }
  mapping(address => uint) public balances; // automatically generates
  function balances(address account) external view returns (uint) {
    return balances[account];
  }
}
    #+END_SRC
- Constant state variable :: The value for a =constant= state variable must be
  assigned at the *compile time*
  #+BEGIN_SRC solidity
contract Contract {
  address public constant ADDR = 0x123;
}
  #+END_SRC
- Immutable state variable :: The value for an =immutable= state variable can be
  assigned at the *construction time* in the constructor. Constant and immutable
  state variables cannot be modified after the contract has been deployed
  #+BEGIN_SRC solidity
contract Contract {
  address public immutable addr;
  constructor() {
    addr = msg.sender;
  }
}
  #+END_SRC

** Contract

- Contract creation :: A contract can be created either by a transaction from an
  external account or by an external call from another contract using a salt to
  randomize the address of the new contract src_solidity{ Contract c = new
  Contract{salt: bytes32}(); }. The contract constructor is executed only once
  when a contract is created. Only one constructor is allowed. The constructor
  overloading is not supported
- Contract deployment :: When a constructor is being executed, the contract is
  not yet deployed. After the constructor has executed, the final immutable
  contract code is stored on the blockchain. The contract code includes all
  public and external functions, as well as all private and internal functions
  reachable from the the public interface of the contract through function
  calls. The deployed contract code does not include the constructor code or
  functions only called from the constructor
- Multiple inheritance :: The inheritance hierarchy of the contract is complied
  into a single contract. All internal calls to functions defined in base
  contracts are implemented as very efficient jumps inside EVM. Shadowing of
  state variables generates an error. Derived contracts must have distinct names
  for state variables. Mark functions of a base contract as =virtual= to
  =override= them in derived contracts. Virtual modifiers can be overridden in
  derived contracts. Multiple base classes are searched in the right-to-left
  revers order of the inheritance. Parent constructors are called in the
  left-to-right order of inheritance. Functions from base contracts can be
  called either ~Base.f()~ or ~super.f()~
  #+BEGIN_SRC solidity
contract Base1 {
  constructor(uint) { }
  modifier m() virtual { _; }
  function f() virtual public { }
}
contract Base2 {
  constructor(uint) { }
  modifier m() virtual { _; }
  function f() virtual public { }
}
// Constructors are called in the left-to-right -> order of inheritance:
// from the most base class to the most derived class
contract Derived is Base1(1), Base2(2) { // static args for base constructors
  // Dynamic args for base constructors
  constructor(uint arg1, uint arg2) Base1(arg1) Base2(arg2) { }
  modifier m() override(Base1, Base2) { _; }
  // Functions are searched in the right-to-left <- reverse order of inheritance
  function f() override(Base1, Base2) public { } // Base2.f is overridden
}
  #+END_SRC
- Abstract contract :: The =abstract= contract has at least one function not
  implemented or the contract does not provide arguments to at least one base
  contract. Abstract contracts cannot be directly created, but must be inherited
  by deriving contracts that implement not implemented functions from the
  abstract contract
- Interface :: The =interface= provides only signatures of implicitly virtual
  functions, not their implementations. The interface can inherit from other
  interfaces. All functions in the interface must be explicitly marked as
  =external= even if the functions will be public in the implementing contracts.
  The interface can define enums, structs, and events
- Library :: The =library= is a set of internal and external functions deployed
  once and reused in the context of the calling contracts through the
  =delegatecall= for the external functions and the efficient jumps inside EVM
  for the internal functions. All referenced internal library functions are
  included in the calling contract during the construction, so calls to internal
  library functions are efficient jumps inside EVM. A library cannot define
  state variables
- Using F for T :: The ~using f, g as +, Lib.e for typ;~ directive attaches free
  functions or library functions to the type within the scope of the contract or
  the scope of a source file. The ~using L for typ;~ directive attaches all
  public library functions to the type. All types are identified with =*=. The
  type is passed as the first argument to the library functions. The left and
  right operands are passed to the library functions that act as operators
- Calling contract function :: The low-level functions =call()=,
  =delegatecall()=, and =staticcall()= operate on an address, not a contract
  instance and all three have the same signature src_solidity{
  address(contract).call{value: 1, gas: 10}(bytes memory args) returns (bool
  success, bytes memory retValues); } and provide fine-grained control over
  encoding of the input arguments and decoding of the return values
  - Call :: The =call()= function switches the EVM state e.g. state variables,
    accounts from the current calling contract to the new called contract, so
    the context of the calling contract is inaccessible
  - Delegate call :: The =delegatecall()= function implements the =library= and
    only uses the code from the target address, while preserving the context
    e.g. state variables, accounts, from the current calling contract
  - Static call :: The =staticcall()= function reverts if the called function
    modifies the state of the current calling contract
  #+BEGIN_SRC solidity
function callFunction(Counter counter) internal {
  bytes memory data = abi.encodeWithSignature("get()");
  bytes4 selector = bytes4(keccak256("get()"));
  bytes memory data = abi.encodeWithSelector(selector);
  bytes memory data = abi.encodeWithSelector(counter.get.selector);
  bytes memory data = abi.encodeCall(counter.get, ());
  (bool success, bytes memory result) = address(counter).call(getData);
  require(success, "get failure");
  (uint value) = abi.decode(result, (uint));
}
  #+END_SRC

*** Inbound payable

- Payable function :: The balance of the contract is automatically updated when
  the =payable= constructor or the =payable= function is executed
- Receive function :: Ether, sent to a contact, is received by the =receive()=
  payable function. The receive function is called if =msg.data= is empty,
  otherwise the payable fallback function is called
- Fallback function :: A contract can have at most one =fallback()= external
  function that is executed when no other contract function matches the call
  signature. The payable fallback function is executed when the =receive()=
  function is not defined or the =msg.data= is not empty
- Relying on exact contract balance is unreliable :: Reverting from the receive
  function and the payable fallback function cannot prevent a contract from
  receiving ether. The actual contract balance can be higher than the internally
  accounted balance
  #+BEGIN_SRC solidity
contract Receive {
  event EvReceive(address indexed from, uint value);

  function deposit() external payable {
    console.log("<== deposit %s", msg.value);
    emit EvReceive(msg.sender, msg.value);
  }

  receive() external payable {
    console.log("<== receive %s", msg.value);
    emit EvReceive(msg.sender, msg.value);
  }

  fallback() external payable {
    console.log("<== fallback %s", msg.value);
    emit EvReceive(msg.sender, msg.value);
  }
}
  #+END_SRC

*** Outbound payable

- Outbound payable :: The =payable= address state variables can send ether via
  the =transfer()=, the =send()=, and the =call()= functions. The high-level
  =transfer()= function reverts on a failure and stops the execution of the
  current contract. The low-level =send()= function returns false on a failure,
  but the execution of the current contract continues. Always check the return
  value of the =send()= function, or better use the =transfer()= function, or
  better let the recipient to withdraw Ether. The recommended way to send ether
  is the =call()= function
  #+BEGIN_SRC solidity
contract Send {
  function send(address payable to) public payable {
    Receive(to).deposit{value: msg.value}();
    to.transfer(msg.value); // not recommended
    bool success = to.send(msg.value); // not recommended
    require(success, "send failure");
    (bool success, ) = to.call{value: msg.value}(""); // recommended
    require(success, "call failure");
  }
}
  #+END_SRC
- Gas :: Gas is the internal unit of computation on the EVM. Gas consumption is
  defined for each EVM instruction. Gas must be provided for a function to be
  executed. Not consumed gas is refunded. The ether value to pay depends on the
  amount of gas spent and the gas price that a caller is willing to pay
  - Transaction as limit :: The gas limit is the maximum amount of gas a caller
    is willing to spend on a transaction
  - Block gas limit :: The block gas limit is the maximum amount of gas set by
    the blockchain that is allowed to be spent on a block

** Functions

- Free function :: The free function outside a contract has implicit =internal=
  visibility, is included in all contracts that call the function. The free
  function is executed in the context of the calling contract, but does not have
  access to =this= and state variables of the calling contract
- Named parameters :: Function arguments can be provided in any order by
  specifying parameter names src_solidity{ f({p1: v1, p2: v2}); }
- Tuple type :: The tuple type is a fixed list of heterogeneous types. The tuple
  is not a proper type in Solidity. The tuple is used to return multiple values
  from a function and for *destructuring assignment* of returned multiple values
  src_solidity{ return (true, 1, "a"); (bool b, uint i, string s) = f(); }
- Function overloading :: The function overloading takes into consideration only
  the types and order of the function parameters, not the return values
- Function type :: The function type is the first class in Solidity. Functions
  can be assigned to variables, passed to functions as arguments, and returned
  from functions as return values. Gas and ether can be provided when calling a
  function src_solidity{ f{value: 1, gas: 10}(); }
- Function selector :: The function selector is the first 4 bytes of the
  Keccak256 hash of the function signature. The function selector identifies a
  public or an external function in a contract during a message call. The
  function selector is located at the first 4 bytes of the call data.
  src_solidity{ bytes4 setSelector = bytes4(keccak256("set(uint256)")); }
- API encoding ::
  - ~abi.encode()~ more secure because not ambiguous, larger, more gas expensive
  - ~abi.encodePacked()~ more probable hash collisions in mapping keys when
    hashing and encoding multiple variable-length values, smaller, gas cheaper
  #+BEGIN_SRC solidity
bytes32 h1 = keccak256(abi.encodePacked([addr1], [addr2, addr3]));
bytes32 h2 = keccak256(abi.encodePacked([addr1, addr2], [addr3]));
require(h1 == h2); // true
  #+END_SRC
- Ambiguous evaluation order :: The order of evaluation of node children in an
  expression tree is not specified. All children are evaluated in an unspecified
  order before the parent node. Short-circuiting of boolean expressions is done.
  Evaluation of functions is not fully deterministic. The evaluation order is
  deterministic for a specific Solidity compiler version, but may not remain
  consistent across different versions. Problem: multiple functions updating the
  same state in a single statement. Solution: avoid expressions and store
  intermediate results in temporary variables
  #+BEGIN_SRC solidity
uint i = 5;
return i * i++; // 25 or 30
return f(g(i), h(i)); // evaluation order of arguments is unspecified
  #+END_SRC

*** Function visibility and mutability

- Function visibility ::
  - Private :: The =private= function is only accessible to the defining
    contract and is not accessible to the derived contracts. All blockchain data
    including the private state of a contract are visible to external objservers
  - Internal :: The =internal= function (default visibility) is accessible to
    the defining contract and to the derived contracts. An internal function can
    take mappings and references to storage variables as parameters. The
    internal function is called by other contract functions directly ~f()~ via a
    simple *jump* in the EVM preserving the memory layout
  - Public :: The =public= function is accessible to other contracts as part of
    the public interface of the contract. A public function can be called either
    internally via a simple jump ~f()~ or externally via a message call
    ~contract.f()~. Public getters are automatically generated for public state
    variables
  - External :: The =external= function is accessible to other contracts as part
    of the public interface of the contract. The external function cannot be
    called internally ~f()~ via a simple jump, but must be called through a
    message call via ~this.f()~. The external function can be only called by
    external accounts and other contracts through a *message call* by specifying
    the contract address, the signature of the external function, and the
    encoded arguments. The external function provides the ~f.address~ of the
    contract and the ABI ~f.selector~. The external function call from one
    contract to another does not create a new transaction, it is only a message
    call within the current transaction. The external function call can specify
    the amount of gas and ether that are added to the balance of the called
    contract ~contr.f{value: 1, gas: 10}();~
- Function state mutability :: The state modifying operations: write to state
  variables, create new contracts, send ether, emit events, call a function not
  marked as view or pure, use low-level calls e.g. ~send()~
  - Pure function :: The =pure= function performs computations without even
    reading the state variables
  - View function :: The =view= function reads the state variables, but does not
    modify the state variables

*** Function modifier

- Function modifier :: The function modifier is a decorator that checks
  pre-conditions before invoking the decorated function and handles
  post-conditions after the function execution. Use modifiers to check for the
  same conditions in multiple functions. A modifier cannot access or change
  function arguments or return values. Function arguments can only be passed to
  a modifier at the point of application src_solidity{ function f(uint a) mod(a)
  { ... } }. A modifier can decide to not execute the function at all. In this
  case the return values of the function are set to default values. Virtual
  modifiers can be overridden in derived contracts
  #+BEGIN_SRC solidity
contract Generocity {
  mapping(address => bool) gifts;
  bool transient locked;

  modifier lock() {
    require(!locked, "reentrant call");
    lock = true;
    _;
    lock = false;
  }

  function claimGift() public lock {
    require(address(this).balance >= 1 ether, "insufficient balance");
    require(!gifts[msg.sender], "gift already claimed");
    (bool success, ) = msg.sender.send{value: 1 ether}("");
    require(success, "gift failed");
    gifts[msg.sender] = true;
  }
}
  #+END_SRC

** Events

- Event :: Emitted events are stored and indexed in the transaction log on the
  blockchain to be consumed by the off-chain infrastructure. Events and logs are
  associated with the contract address, but are not accessible from within the
  emitting contract. Events should be emitted to log all significant changes in
  a smart contract e.g. deposits, withdrawals, configuration changes
- Event indexing :: At most three event fields can be =indexed= and placed into
  topics that provide efficient search by exact match on the indexed fields. The
  keccak256 hash of the event signature is placed into the first default topic.
  A topic can only hold 32-byte words. A keccak256 hash of indexed reference
  types is stored in a topic. All not indexed event fields are stored in the
  data part of the transaction log. Event emitting functions cannot be pure or
  view functions, as they alter the blockchain by storing logs

** Error handling

- Assert function :: The =assert= function causes a ~Panic(uint)~ when a
  condition is not met. The assert function is used only for checking internal
  invariants e.g. division by zero, arithmetic overflow, arithmetic underflow,
  out-of-bounds array access, data conversion error, corrupted data, explicit
  assert e.g. src_solidity{ assert(cond) }
- Revert statement :: The =revert= statement reverts all changes to the state
  when a condition is not met. The revert statement is used for complex
  conditions
  #+BEGIN_SRC solidity
error ErrInsufficientFunds(uint requested, uint available);
if (balances[msg.sender] <= value) {
  revert ErrInsufficientFunds(value, balances[msg.sender]);
}
  #+END_SRC
- Require function :: The =require= convenience function reverts all changes to
  the state when a condition is not met. The =revert= statement and the
  =require= function are equivalent, but the require function is more convenient
  #+BEGIN_SRC solidity
require(balances[msg.sender] <= value, "insufficient funds");
require(
  balances[msg.sender] <= value,
  ErrInsufficientFunds(value, balances[msg.sender])
);
  #+END_SRC
- try/catch statement :: The =try/catch= statement handles errors when only
  external function calls or a =new= contract creation has reverted. Reverts in
  internal function calls or inside the same function cannot be caught
  #+BEGIN_SRC solidity
try this.externalCall() returns (uint returnValue) {
  // success: returnValue
} catch Error(string memory message) {
  // Error message
} catch Panic(uint code) {
  // Panic code
} catch (bytes memory err) {
  bytes memory expErr = abi.encodeWithSignature(
    "ErrOh(string)", "revert error"
  );
  assertEq(err, expErr);
}
try new Contract() returns (Contract contract) {
  // success: contract
} catch {
  // catch all errors
}
  #+END_SRC

** Import

- Import :: The =import= statement imports all or explicitly selected global
  symbols from the imported file into the global scope of the current file
  #+BEGIN_SRC solidity
import "path"; // imports all symbols
import { A, B as BB } "path"; // imports only selected symbols
import * as alias from "path" // imports all symbols under the alias
  #+END_SRC

** Layout

- File layout :: SPDX license, =pragma=, =import=, =event=, =error=, =interface=,
  =library=, =contract=
- Contract layout :: =enum=, =struct=, state, =event=, =error=, =modifier=,
  =constructor=, =function=
- Function modifiers layout ::
  - Visibility :: =private=, =internal=, =public=, =external=
  - Mutability :: =pure=, =view=, =payable=
  - Inheritance :: =virtual=, =override=
  - Modifier :: Custom modifiers


* Security

** Security principles

- Principle of least privilege :: A system should grant only the minimum
  necessary rights to a subject to perform the required function
  - Enforce authorization with Solidity access control modifiers e.g.
    OpenZeppeling Owneable abstract contract
  - Minimize the amount of data a function can access and modify
- Defensive programming :: Validate data and check for unsatisfied conditions as
  soon as possible before executing an action
- Keep it simple
  - Design modular and composable functions and contracts
  - Prefer clarity over performance
  - Only use the blockchain for critical data and operations
- Blockchain properties
  - The *private data of a contract is publicly viewable* on a blockchain. To
    preserve data privacy on a blockchain use a *commit-reveal scheme* where the
    salted hash of a private data is stored on the blockchain, and later the
    data and the salt matching the published hash are revealed
  - The public interface of a contract can be called maliciously
  - Calls to external contracts that may execute malicious code
  - Timestamps are imprecise on a blockchain. If the contract logic maintains
    integrity with the 15 seconds margin, that it is safe to use
    =block.timestamp= which can be manipuated by a miner
  - Randomness is non-trivial on a blockchain
- Prepare for failure, graceful error handling
  - Prepare a smart contract to gracefully handle bugs and vulnerabilities
  - Circuit breaker :: Use a circuit breaker to stop programmatically or on
    demand the failing contract when certain conditions are met
    #+BEGIN_SRC solidity
contract C {
  bool stopped;
  function stop() public only(owner) isStopped(false) {
    stopped = true;
  }
  function deposit() isStopped(false) { }
  function withdraw() only(owner) isStopped(true) { }
}
    #+END_SRC
  - Rate limiter :: Use a rate limiter and quotas to limit the frequency of
    requests and the value at risk by introducing deliberate delays in contract
    actions e.g. deferred withdrawals, deferred activation of configuration
    changes
    #+BEGIN_SRC solidity
contract C {
  struct Withdrawal { uint value; uint timestamp; }
  mapping(address => uint) balances;
  mapping(address => Withdrawal) withdrawals;
  function requestWithdrawal() public {
    address withdrawer = msg.sender;
    uint value = balances[withdrawer];
    require(value > 0, ErrNothingToWithdraw(withdrawer));
    balances[withdrawer] = 0;
    withdrawals[withdrawer] = Withdrawal(value, block.timestamp + 7 days);
  }
  function withdraw() public {
    address withdrawer = msg.sender;
    Withdrawal storage withdrawal = withdrawals[withdrawer];
    require(withdrawal.value > 0, ErrNothingToWithdraw(withdrawer));
    require(block.timestamp > withdrawal.timestamp, ErrTooEarly(withdrawer));
    uint value = withdrawal.value;
    withdrawal.value = 0;
    (bool success, ) = withdrawer.call{value: value}("");
    require(success, ErrWithdraw(withdrawer));
  }
}
    #+END_SRC
  - Contract upgrade :: Set up an effective upgrade path for fixes and
    improvements. Code of deployed contracts is immutable. A contract upgrade
    implies a single owner or a multisig authority with the power to trigger an
    update (some centralization)
    - Registry contract :: Use a registry contract that holds the address of the
      latest version of the contract. Users must always lookup the latest
      address
      #+BEGIN_SRC solidity
contract Registry {
  address current;
  function upgrade(address next) external only(owner) {
    require(next != address(0) && next != current, ErrInvalidContract(next));
    current = next;
    emit EvUpgrade(next);
  }
}
      #+END_SRC
    - Relay contract, transparent proxy :: A relay contract stores all state
      across multiple versions of delegated logic contracts. The relay contract
      forwards calls via the =delegatecall= in the =fallback()= function to the
      latest version of the logic contract. The called logic contract must have
      the same storage layout as the calling relay contract. The relay contract
      only forwards calls, but does not return values from the logic contract.
      Admin calls are not forwarded to the logic contract, but executed directly
      on the relay contract to update its configuration
      #+BEGIN_SRC solidity
contract Relay is Registry {
  fallback() external payable {
    (bool success, ) = current.delegatecall(msg.data);
    require(success, ErrRelay(msg.data));
  }
}
      #+END_SRC
- Testing strategy :: Fixes bugs, introduces performance optimizations,
  integrates quality-of-life features
  - Isolated testing :: Local linting, unit, integration, and property-based
    fuzzy testing with 100% coverage
  - Local testnet :: Deploy to a local testnet forked from the mainnet for the
    private on-chain testing in realistic conditions. Use Foundry cheatcodes to
    simulate unexpected and failure conditions
  - Public testnet :: Deploy to a public testnet for the volume testing in a
    more unpredictable environment, bug bounties and external beta testers
  - Mainnet in beta :: Deploy to the mainnet in beta with the limited value at
    risk and extensive monitoring of the activity of a smart contract
  - Mainnet release :: Mainnet release
- Frontrunning :: Every pending transaction is visible in the mempool before
  execution. The public knowledge of already submitted, but not yet executed
  transactions allows to submit another transaction with higher fees targeting
  the same assets, before the original transaction is included into a block
  - Displacement :: The original transaction is processed on an already invalid
    state after the malicious transaction with higher fees has been processed
  - Insertion :: The original transaction is processed on a modified state after
    the malicious transaction with higher fees has been processed
  - Suppression, block stuffing :: The execution of ordinary transactions e.g.
    oracle updates is significantly delayed by placing other transactions with
    high fees
  - Mitigation of frontrunning :: Reduce the benefits of frontrunning in the
    contract by minimizing the importance of transaction ordering or transaction
    timing e.g. a commit-reveal scheme
- Reentrancy :: A called external function performs an unanticipated call into
  the calling original function initiating multiple half-completed executions of
  the original function leading to a cascade of state changes. Mitigation: use
  the checks-effects-interactions design pattern. No state change must occur
  after an external call. State changes after an external call enable the
  vulnerability
  #+BEGIN_SRC solidity
contract Reentrancy {
  mapping(address => unit) balances;
  // An attacker repeatedly calls back the function until all funds of the
  // contract are drained. The attacker must stop when the contact balnce or the
  // gas left is zero, otherwise the whole operation will be reverted
  function withdraw() external {
    address withdrawer = msg.sender;
    uint value = balances[withdrawer];
    balances[withdrawer] = 0; // SAFE state change BEFORE the external call
    (bool success, ) = withdrawer.call{value: value}("");
    require(success, ErrWithdraw(withdrawer));
    balances[withdrawer] = 0; // UNSAFE state change AFTER the external call
  }
}
  #+END_SRC

** Development recommendations

*** External calls

- External calls :: Treat external contract calls ~contract.function()~ and
  external raw calls ~address.function()~ calls as a potential security risk
- Handle errors in low-level raw calls :: Explicitly handle the bool return
  value of low-level raw calls operating on addresses e.g. ~address.call()`,
  ~address.staticcall()~. Contract calls ~contract.function()~ automatically
  revert
- Checks-effects-interactions :: First perform all checks using the =require()=.
  Then make state changes by modifying state variables. Only then call external
  contracts. Avoid state changes after external calls
- Prefer call over transfer and send :: Prefer the =call()= over the
  =transfer()= and =send()=. The transfer and the send functions forward only
  2300 gas, which may not be enough if the recipient is a contract or the cost
  of EVM instructions changes. The call function forwards all available gas
  #+BEGIN_SRC solidity
// avoid
msg.sender.transfer(value);
// prefer
(bool success, ) = msg.sender.call{value: value}("");
require(success, ErrTransfer());
  #+END_SRC
- Prefer pull over push for external calls :: Minimize damage of a failure of an
  external call by isolating the external call into its own transaction
  initiated by the recipient. E.g. let users withdraw funds rather then pushing
  funds to them automatically, avoid combining multiple transactions into a
  single transaction, avoid looping over an arbitrary large array whose
  processing may reach the block gas limit and revert the whole transaction.
  Split a large array into multiple blocks processed in isolated transactions
- Do not delegate call to untrusted code :: ~address.delegatecall()~ executes
  functions from external contracts in the context of the calling contract. The
  untrusted external contract may change the state of the calling contract.
  Delegate calls only to trusted contracts. Never delegate calls to a
  user-supplied address
- msg.sender vs tx.origin :: If a contact =A= calls a contract =B= and a
  contract =B= calls a contract =C=, then in the contract =C= =tx.origin= is =A=
  and =msg.sender= is =B=. Always use =msg.sender= for authorization. Never use
  =tx.origin= for authorization
- Prevent transferring tokens to the contract's own address
  #+BEGIN_SRC solidity
modifier validRecipient(address to) {
  require(to != address && to != address(this), ErrInvalidRecipient(to));
  _;
}
  #+END_SRC
