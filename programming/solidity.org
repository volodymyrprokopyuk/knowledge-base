* Solidity

** Types

*** Value types

- Value types :: The value types are always *passed by value* as function
  arguments and in the assignment. The value types are *always stored on the
  stack*, hence the declarations of value types do not specify the data
  location. The only exception are state variables of value types marked with
  the =storage= data location. The value types can also be marked as =transient=
  cheaper than storage with the transaction lifetime, =constant= compile-time
  without memory allocation, or =immutable= construction time with memory
  allocation
- Default zero value :: Declared, but not initialized variables automatically
  get assigned the type-specific default value whose byte representation is *all
  zeros*. Undefined or null values are not possible in Solidity
- Arbitrary precision on number literals :: Number literals retain the arbitrary
  precision until they are converted into a specific value type. Computations do
  not overflow nor underflow when performed in number literals. Most operands
  produce a literal expression when applied to literals. The division of
  literals results in a fractional value of arbitrary precision. The division of
  integers rounds towards zero
- Checked arithmetic operations :: All arithmetic operations are checked by
  default and revert on an underflow or an overflow. ~unchecked { ... }~ block
  disables the arithmetic checks and saves gas
- Ether units :: Numbers can have the =wei=, the =gwei=, and the =ether= suffix
  to identify the ether value. Numbers without a suffix are assumed to be in
  =wei=
| Ether unit | Ether value             |
| =1 wei=    | =1e-18 ether=           |
| =1 gwei=   | =1e-9 ether=, =1e9 wei= |
| =1 ether=  | =1e18 wei=, =1e9 gwei=  |
- Address :: An address represents an external address or a contract address
- Payable address :: An external address or a contract address with a
  =receive()= function, or a =fallback() payable= function that accepts Ether
- Payable function :: A function that receives ether must be =payable=
- User-defined value type :: A user-defined value type creates a *zero-cost
  abstraction* over the underlying built-in value type. The user-defined value
  type has neither operators nor attached functions, only explicit conversion to
  and from the underlying value type is supported through the =wrap()= and
  =unwrap()= functions

| Value type                           | Operators and functions                 |
|--------------------------------------+-----------------------------------------|
| =bool=, =true=, =false=              | Logical, comparison ~!, &&, ¦¦, ==, !=~ |
| ~int = int256~, ~uint = uint256~     | Comparison ~<, <=, >=, >, ==, !=~       |
|                                      | Bitwise =~, &, ¦, ^, <<, >>=            |
|                                      | Arithmetic ~+, -, *, /, %, **~          |
|                                      | Min/max ~type(int).min, type(uint).max~ |
| ~fixed = fixed128x18~                | Fixed point number                      |
| ~ufixed = ufixed128x18~              | with variable precision                 |
| =address=                            | Literal =0x123..abc= (20 bytes)         |
| =address payable=                    | Balance =payable(address).balance=      |
| =bytes1= .. =bytes32=                | Fixed padded array up to 32 bytes       |
|                                      | Comparison ~<, <=, >=, >, ==, !=~       |
|                                      | Bitwise =~, &, ¦, ^, <<, >>=            |
|                                      | Indexing, length ~arr[i], arr.length~   |
| ="string"=, =unicode"string"=        | ASCII and Unicode strings               |
| =hex"1a2b"=, =0x12ab=                | Hex literal                             |
| ~enum State { Default, Start, End }~ | ~type(State).min~, ~type(State).max~    |
|                                      | ~state == State.Start~, ~delete state;~ |
| ~type Year is uint;~                 | ~Year.wrap(2024)~, ~Year.unwarp(year)~  |

*** Reference types

- Reference types :: The reference types define a shared memory location
  accessible through multiple different references. The reference types are
  =array=, =bytes=, =stirng=, =mapping=, and =struct=

**** Arrays

- Fixed array :: Each element of a fixed array ~T[k] arr;~ is initialized with
  the default zero value for the element type =T=. Fixed arrays of different
  sizes are distinct types and cannot be converted into each other. A fixed
  array cannot be assigned to a dynamic array
- Dynamic array :: Each element of a dynamic array ~T[] arr;~ is initialized
  with the default zero value for the element type =T=. The =storage= dynamic
  array automatically grows as elements are added to the array. The =memory=
  dynamic array does not grow. The notation is reversed e.g. ~T[][4]~ is the
  fixed array of 4 dynamic arrays. The element access is in the opposite
  direction to the declaration e.g. ~t[0][1]~ is the first element of the second
  dynamic array
- Array literal :: The type of an array literal is the type of the first element
  with all other elements implicitly convertible to the type of the first
  element
- Array slice :: An array slice represents a view on the array e.g.
  ~arr[start:end]~
  #+BEGIN_SRC solidity
uint[4] memory arr; // A fixed array initialized with the default zero value
arr[0] = 10; // Assignement
uint[] memory arr = new uint[](4); // A memory dynamic array does not grow
uint[] storage arr = [1, 2, 3]; // An explicit initialization
arr.push(4); // Only storage dynamic arrays grow automatically
if (arr.length > 0) {
  delete arr[0]; // Reset the first element to the default zero value
  arr.pop(); // Remove the last element
  delete arr; // Reset the array to a new empty array
}
  #+END_SRC

**** Bytes and string

- Bytes array :: The =bytes= is a special type of array with *packed data* for
  storing *binary data*. The =bytes1[]= adds padding to each element. Prefer a
  fixed array of =bytes1= .. =bytes32= over a dynamic array =bytes=. Bytes
  concatenation ~bytes.concat(b1, b2)~
- String array :: The =string= is equivalent to =bytes= for *Unicode*, but does
  not allow the length and the index access. String concatenation
  ~string.concat(s1, s2)~
  #+BEGIN_SRC solidity
// Comparison of strings
keccak256(abi.encodePacked(s1)) == keccak256(abi.encodePacked(s2))
// Low-level bytes manipulation, not Unicode code points
bytes(s).length; bytes(s)[k] = value;
  #+END_SRC

**** Mapping

- Mapping :: The ~mapping(keyType keyName => valueType valueName)~ with optional
  key name and value name stores values under the *keccak256 hash of the key*.
  Only the hash of a key is stored in a mapping, hence *keys are not
  enumerable*, and must be known in order to access the corresponding values.
  The default zero value is returned for unset keys. The mapping can have only
  the =storage= data location, hence mappings are used for state variables and
  as references to passed state variables in functions. Mappings can be *nested*
- Delete :: The =delete= operator assigns the default zero value to a variable,
  an array position, a mapping slot, or a struct field. The delete operator
  assigns an empty fixed or dynamic array to an array variable. The delete
  operator has no effect on mappings, unless the delete operator is applied to a
  specific key within the mapping
  #+BEGIN_SRC solidity
mapping(address addr => uint bal) balances;
balances[addr] = 1; // Set a value for the key
if (balances[addr] > 0) {
  delete balances[addr]; // Reset the key with the default value
}
// A nested mapping
mapping(address own => mapping(address spn => uint remVal)) public allowance;
  #+END_SRC

**** Struct

- Struct :: A =struct= defines a new user-defined type. Arrays and mappings
  can have structs and vice versa. Recursive structs are not supported

| Reference type          | Fields and functions                                 |
| Fixed array ~T[k]~      | =arr.length=, ~arr[i]~, ~arr.push(v);~, ~arr.pop();~ |
| Dynamic array ~T[]~     | ~delete arr[k];~, ~delete arr;~                      |
| ~mapping(key => vlaue)~ | ~map[key] = value;~, ~delete map[key];~              |
| ~struct A { uint a; }~  | ~A a = A(1);~, ~A a = A({a: 1});~, ~A a; a.a = 1;~   |
|                         | ~delete a.a;~, ~delete a;~                           |

** Variables

*** Variable types

- Local variable :: A local variable is defined and used within the scope of a
  function. A local variable is allocated on the stack and is not stored on the
  blockchain
- Storage variable :: A storage variable is defined and used within the scope of
  a contract. A storage variable is stored on the blockchain. A write to a
  storage variable must be within a transaction. A read from a storage variable
  does not require a transaction
- Global variable :: The global variables are implicitly provided by the EVM and
  the Solidity runtime e.g. =msg.sender=, =msg.value=, =block.number=,
  =block.timestamp=

*** Storage and memory

- Data location :: A data location specifies where a declared variable is
  allocated. The data location =storage=, =transient=, =calldata=, and =memory=
  must be specified for declarations of reference types. The =storage= data
  location for state variables within a contract can be omitted
- Permanent storage :: The =storage= data location stores state variables in a
  per contract expensive persistent key-value store in the form of
  ~mapping(bytes => bytes)~ stored on the blockchain
- Transient storage :: The =transient= data location is less expensive than the
  =storage= data location and is reset at the end of each transaction
- Calldata :: The =calldata= data location stores function arguments in a
  read-only, volatile, memory-like data location that avoids unnecessary copies
  of data to save gas
- Memory :: The =memory= data location is accessible within the scope of a
  function, and provides 32-bytes reads, and 1-byte and 32-bytes writes
- Stack :: The EVM is a *stack-based machine*, not a register-based machine. All
  computations are performed on the stack with the max 1024 32-bytes words

*** State variables

- State variables :: State variables are either permanently stored in the
  contract =storage= on the blockchain or temporarily stored in the =transient=
  storage that is reset at the end of each transaction
- State variable visibility :: The visibility of state variables only prevents
  derived or other contracts from reading or writing state variables, but all
  state is publicly available for reading on the blockchain
  - Private :: A =private= state variable is only accessible to the defining
    contract and is not accessible to derived contracts
  - Internal :: An =internal= state variable (default visibility) is accessible
    to the defining contract and to derived contracts
  - Public :: A =public= state variable is read-only accessible to other
    contracts through an automatically generated getter view function. Public
    state variables allow direct access via the direct reference =owner= or
    external access through a getter via =this.owner=
    #+BEGIN_SRC solidity
contract Contract {
  address public owner; // A value type automatically generates
  function owner() external view returns (address) {
    return owner;
  }
  uint[] public values; // An array automatically generats
  function values(uint i) external view returns (uint) {
    return values[i];
  }
  mapping(address addr => uint bal) public balances;
  // A mapping automatically generates
  function balances(address addr) external view returns (uint) {
    return balances[addr];
  }
}
    #+END_SRC
- Constant state variable :: The value for a =constant= state variable must be
  assigned at the *compile time*. A constant state variable does not consume
  memory
  #+BEGIN_SRC solidity
contract Contract {
  address public constant ADDR = 0x123;
}
  #+END_SRC
- Immutable state variable :: The value for an =immutable= state variable can be
  assigned at the *construction time* in the constructor. Constant and immutable
  state variables cannot be modified after the contract has been deployed
  #+BEGIN_SRC solidity
contract Contract {
  address public immutable addr;
  constructor() {
    addr = msg.sender;
  }
}
  #+END_SRC

** Functions

*** Function type

- Function type :: A function type is the *first class* in Solidity. Functions
  can be assigned to variables, passed to functions as arguments, and returned
  from functions as return values. *Ether and gas* can be provided when calling
  a function src_solidity{ f{value: 1, gas: 10}(); }
- Function overloading :: The function overloading takes into consideration only
  the types and the order of function parameters, not return values
- Function selector :: A function selector is the first 4 bytes of the Keccak256
  hash of the function signature. A function selector identifies a public or an
  external function in a contract during a message call. A function selector is
  located at the first 4 bytes of the call data follower by ABI-encoded
  arguments. src_solidity{ bytes4 selector = bytes4(keccak256("set(uint256)"));
  }
- ABI encoding ::
  - ~abi.encode()~ not ambiguous, larger, more gas expensive
  - ~abi.encodePacked()~ ambiguous, because of hash collisions when encoding and
    hashing multiple variable-length values, smaller, more gas efficient
    #+BEGIN_SRC solidity
  bytes32 h1 = keccak256(abi.encodePacked([addr1], [addr2, addr3]));
  bytes32 h2 = keccak256(abi.encodePacked([addr1, addr2], [addr3]));
  require(h1 == h2); // true
    #+END_SRC
- Named parameters :: Function arguments can be provided in any order by
  specifying parameter names src_solidity{ f({p1: v1, p2: v2}); }
- Tuple type :: A tuple type is a fixed list of heterogeneous types. The tuple
  is not a proper type in Solidity. The tuple is only used to *return multiple
  values* from a function and for *destructuring assignment* of returned
  multiple values src_solidity{ return (true, 1, "a"); (bool b, uint i,
  string s) = f(); }
- Free function :: A free function outside a contract has implicit =internal=
  visibility, and is included in all contracts that call the function. A free
  function is executed in the context of the calling contract, but does not have
  access to =this= and state variables of the calling contract
- Ambiguous evaluation order :: The order of evaluation of node children in an
  expression tree is not specified. All children are evaluated in an unspecified
  order before the parent node. Short-circuiting of boolean expressions is done.
  Evaluation of functions is not fully deterministic in Solidity. The evaluation
  order is deterministic for a specific Solidity compiler version, but may not
  remain consistent across different versions. Problem: multiple functions
  updating the same state in a single statement may be executed in different
  order by different Solidity compiler versions. Solution: avoid expressions
  that involve multiple functions and *store intermediate results in temporary
  variables*
  #+BEGIN_SRC solidity
uint i = 5;
return i * i++; // 25 or 30
return f(g(i), h(i)); // The evaluation order of arguments is unspecified
  #+END_SRC

*** Function visibility

- Private :: A =private= function is only accessible to the defining contract
  and is not accessible to derived contracts. All blockchain data including the
  private state of a contract are visible to external observers
- Internal :: An =internal= function (default visibility) is accessible to the
  defining contract and to derived contracts. An internal function is called by
  other contract functions directly ~f()~ via a simple jump in the EVM
  preserving the memory layout. An internal function can take mappings and
  references to storage variables as parameters
- Public :: A =public= function is accessible to other contracts as part of the
  public interface of the contract. A public function can be called either
  internally via a simple jump ~f()~ or externally via a message call ~ctr.f()~.
  Public getter functions are automatically generated for public state variables
- External :: An =external= function is only accessible to other contracts as
  part of the public interface of the contract through a message call via
  ~ctr.f()~. An external function call from one contract to another contract
  *does not create a new transaction*, it is only a message call within the same
  transaction. An external function call can specify *ether and gas* that are
  added to the balance of the called contract ~ctr.f{value: 1, gas: 10}();~

*** Function mutability

- Function state mutability :: The state modifying operations: write to state
  variables, create new contracts, call a function not marked as view or pure,
  emit events, send ether, use low-level calls
  - Pure function :: A =pure= function performs computations only with function
    arguments without reading state variables
  - View function :: A =view= function only reads state variables, but does not
    modify state variables

*** Function modifier

- Function modifier :: A function modifier is a function decorator that checks
  pre-conditions before invoking the decorated function, and handles
  post-conditions after the execution of the function. Use modifiers to check
  for the same conditions in multiple functions. A modifier cannot access or
  change function arguments or return values. Function arguments can be
  explicitly passed to a modifier at the point of application src_solidity{
  function f(uint a) mod(a) { ... } }. A modifier can decide to not execute the
  function at all. In this case the return values of the function are set to the
  default zero values. Virtual modifiers can be overridden in derived contracts.
  A modifier should not have side effects e.g. update state, except the
  reentrancy lock, or perform external calls
  #+BEGIN_SRC solidity
contract Gifts {
  mapping(address addr => bool claimed) claims;
  bool transient locked;

  modifier lock() {
    require(!locked, "reentrant call");
    lock = true;
    _;
    lock = false;
  }

  function claim() public lock {
    require(address(this).balance >= 1 ether, "insufficient funds");
    address claimer = msg.sender
    require(!claims[claimer], "already claimed");
    claims[claimer] = true;
    (bool succ, ) = claimer.send{value: 1 ether}("");
    require(succ, "claim failed");
  }
}
  #+END_SRC

*** Error handling

- Assert function :: The =assert= function causes a ~Panic(uint)~ when a
  condition is not met. The assert function is used only for checking internal
  invariants e.g. division by zero, arithmetic overflow, arithmetic underflow,
  out-of-bounds array access, data conversion error, corrupted data, explicit
  assert e.g. ~assert(cond)~
- Revert statement :: The =revert= statement reverts all changes to the state
  when a condition is not met. The revert statement inside the if statement is
  used for complex conditions
  #+BEGIN_SRC solidity
error ErrInsufficientFunds(uint requested, uint available);
if (balances[msg.sender] < value) {
  revert ErrInsufficientFunds(value, balances[msg.sender]);
}
  #+END_SRC
- Require function :: The =require= convenience function reverts all changes to
  the state when a condition is not met. The =revert= statement and the
  =require= function are equivalent, but the require function is more convenient
  #+BEGIN_SRC solidity
require(balances[msg.sender] < value, "insufficient funds");
require(
  balances[msg.sender] < value,
  ErrInsufficientFunds(value, balances[msg.sender])
);
  #+END_SRC
- try/catch statement :: The =try/catch= statement handles errors only when
  external function calls ~ctr.f()~ or a =new= contract creation has reverted.
  Reverts in internal function calls or inside the same function cannot be
  caught
  #+BEGIN_SRC solidity
try this.externalCall() returns (uint returnValue) {
  // success: returnValue
} catch Error(string memory message) {
  // Error message
} catch Panic(uint code) {
  // Panic code
} catch (bytes memory err) {
  bytes memory expErr = abi.encodeWithSignature(
    "ErrOh(string)", "revert error"
  );
  assertEq(err, expErr);
}
try new Contract() returns (Contract contract) {
  // success: contract
} catch {
  // catch all errors
}
  #+END_SRC

** Contract

*** Inheritance

- Multiple inheritance :: The inheritance hierarchy of a contract is complied
  into a single contract bytecode. All internal calls to functions defined in
  base contracts are implemented as very efficient jumps inside EVM. Shadowing
  of state variables generates an error. Derived contracts must have distinct
  names for state variables. Mark functions or modifiers of a base contract as
  =virtual= to =override= them in derived contracts. Parent constructors are
  called in the left-to-right order of inheritance. Multiple base classes are
  searched in the right-to-left reverse order of the inheritance. Functions from
  base contracts can be called either ~Base.f()~ or ~super.f()~
  #+BEGIN_SRC solidity
contract Base1 {
  constructor(uint) { }
  modifier m() virtual { _; }
  function f() virtual public { }
}
contract Base2 {
  constructor(uint) { }
  modifier m() virtual { _; }
  function f() virtual public { }
}
// Constructors are called in the left-to-right -> order of inheritance:
// from the most base class to the most derived class
contract Derived is Base1(1), Base2(2) { // Static args for base constructors
  // Dynamic args for base constructors
  constructor(uint arg1, uint arg2) Base1(arg1) Base2(arg2) { }
  modifier m() override(Base1, Base2) { _; }
  // Functions are searched in the right-to-left <- reverse order of inheritance
  function f() override(Base1, Base2) public { } // Base2.f is overridden
}
  #+END_SRC

*** Interface and library

- Abstract contract :: An =abstract= contract has at least one not implemented
  function or the contract does not provide arguments to at least one base
  constructor. Abstract contracts cannot be directly created, but must be
  inherited by deriving contracts that implement not implemented functions from
  the abstract contract
- Interface :: An =interface= provides only signatures of implicitly =virtual=
  functions, not their implementations. All functions in an interface must be
  explicitly marked as =external=, even if the functions will be =public= in the
  implementing contracts. An interface can define =enum=, =struct=, =event=, and
  inherit from other interfaces.
- Library :: A =library= is a set of internal and external functions deployed
  once and reused in the context of calling contracts. A library cannot define
  state variables. All library functions are stateless. External library
  functions are called through the =addr.delegatecall=. Internal functions are
  implemented as efficient jumps inside EVM. All internal library functions
  referenced by a calling contract are included in the calling contract during
  the construction, so calls to internal library functions are efficient jumps
  inside EVM.
- Using F for T :: The ~using f, g as +, Lib.e for typ;~ directive attaches free
  functions or library functions to the type within the scope of the contract or
  the scope of a source file. The ~using Lib for typ;~ directive attaches all
  public library functions to the type. All types are identified with =*=. The
  type is passed as the first argument to a library function. The left and right
  operands are passed to a library function that acts as an operator

*** Contract calls

- Low-level calls :: The low-level functions =call()=, =delegatecall()=, and
  =staticcall()= operate on an address, not a contract instance and all three
  have the same signature src_solidity{ address(contract).call{value: 1, gas:
  10}(bytes memory args) returns (bool success, bytes memory retValues); } and
  provide fine-grained control over encoding of the input arguments and decoding
  of the return values
  - Call :: The =call()= function switches the EVM state to the new called
    contract, so the context of the calling contract is inaccessible
  - Delegate call :: The =delegatecall()= function implements the =library=
    feature, preserves the context of the current calling contract e.g.
    =msg.sender=, =msg.value=, including the sequential slot structure of state
    variables, and only uses the code from the target library address
  - Static call :: The =staticcall()= function reverts if the called function
    modifies the state of the current calling contract
    #+BEGIN_SRC solidity
  function callFunction(Counter counter) internal {
    bytes memory data = abi.encodeWithSignature("");
    bytes4 selector = bytes4(keccak256("get()"));
    bytes memory data = abi.encodeWithSelector(selector);
    bytes memory data = abi.encodeWithSelector(counter.get.selector);
    bytes memory data = abi.encodeCall(counter.get, ());
    (bool succ, bytes memory result) = address(counter).call(data);
    require(succ, "get failure");
    (uint value) = abi.decode(result, (uint));
  }
    #+END_SRC

*** Contract creation

- Smart contract :: A smart contract has associated an immutable contract code,
  a contract storage, and a contract balance. The contract balance is controlled
  by the code, not a private key. A contract does not have a private key. In
  contrast an externally owned account is controlled by a private key managed by
  a wallet. The immutable contract code is deterministically executed on the EVM
  causing state transitions on the global Ethereum state machine
- Contract creation :: A contract can be deployed to a contract address by a
  transaction from an external account. A contract can also be locally
  instantiated by another contract using a salt to randomize the address of a
  new contract src_solidity{ Contract ctr = new Contract{salt: bytes32}(); }.
  The contract constructor is executed only once when a contract is created.
  Only one constructor is allowed
- Contract deployment :: When a constructor is executed, the contract is not yet
  deployed. After the constructor has executed, the final immutable bytecode of
  the contract is stored on the blockchain under the contract address. The
  contract bytecode includes all public and external functions, as well as all
  private and internal functions reachable from the public interface of the
  contract through function calls. The deployed contract bytecode does not
  contain the bytecode of the constructor or functions only called from the
  constructor

*** Inbound payable

- Payable function :: The balance of a contract is automatically updated when a
  =payable= constructor or a =payable= function is executed
- Receive function :: Ether, sent to a contact, is received by the =receive()=
  payable function. The receive function is called if =msg.data= is empty,
  otherwise the payable fallback function is called
- Fallback function :: A contract can have at most one =fallback()= external
  function that is executed when no other contract function matches the call
  signature. The payable fallback function is executed when the =receive()=
  function is not defined or the =msg.data= is not empty
- this.balance is unreliable :: The actual contract balance can be higher than
  the balance internally tracked in a state variable. Reverting from the
  =receive()= function and the payable =fallback()= function cannot prevent a
  contract from receiving ether.
  - Construct :: Ether can be sent to a pre-calculated address of a contract
    before the creation of a contract
  - Self destruct :: The ~selfdestruct(address)~ instruction unconditionally
    sends ether of the contract being destroyed to the specified address without
    invoking any payable function of the specified contract
  - Mitigation: track the balance of a contract in a state variable updated by
    payable functions. The state variable may have a lower balance than the
    actual contract ~this.balance~, but the state variable is not influenced by
    the ether forcibly sent to the contract, and won't lock funds forever
    #+BEGIN_SRC solidity
  contract Receive {
    event EvReceive(address indexed from, uint value);

    function deposit() external payable {
      console.log("<== deposit %s", msg.value);
      emit EvReceive(msg.sender, msg.value);
    }

    receive() external payable {
      console.log("<== receive %s", msg.value);
      emit EvReceive(msg.sender, msg.value);
    }

    fallback() external payable {
      console.log("<== fallback %s", msg.value);
      emit EvReceive(msg.sender, msg.value);
    }
  }
    #+END_SRC

*** Outbound payable

- Outbound payable :: A =payable= address can send ether via the =transfer()=,
  the =send()=, and the =call()= functions. The high-level =transfer()= function
  reverts on a failure and stops the execution of the current contract. The
  low-level =send()= function returns false on a failure, but the execution of
  the current contract continues. Always check the return value of the =send()=
  function, or better use the =transfer()= function, or better let the recipient
  to withdraw Ether. The recommended way to send ether is the =call()= function
  #+BEGIN_SRC solidity
contract Send {
  function send(address payable to) public payable {
    Receive(to).deposit{value: msg.value}();
    to.transfer(msg.value); // not recommended
    bool success = to.send(msg.value); // not recommended
    require(success, "send failure");
    (bool success, ) = to.call{value: msg.value}(""); // recommended
    require(success, "call failure");
  }
}
  #+END_SRC
- Gas :: Gas is a virtual currency of Ethereum with a variable exchange rante
  against ether. Gas is the internal unit of computation and storage on the EVM.
  Gas consumption is defined for each EVM instruction. Gas must be provided for
  a function to be executed. Not consumed gas is refunded to the sender. The
  ether value to pay depends on the amount of gas spent and the gas price that a
  caller is willing to pay
  - Gas price :: The gas price a sender is willing to pay to prioritize
    inclusion of a transaction
  - Transaction gas limit :: The gas limit is the maximum amount of gas a caller
    is willing to spend on a transaction. The gas limit prevents DoS
  - Block gas limit :: The block gas limit is the maximum amount of gas set by
    the blockchain that is allowed to be spent on a block

*** Events

- Event :: Events emitted during the contract execution are stored in the chain
  data associated with the contract address as *transaction receipts* under the
  *logs section*. *Indexed* event fields are stored in *topics* for efficient
  search. Events should be emitted to log all significant changes in a smart
  contract e.g. deposits, withdrawals, configuration changes
- Event indexing :: At most three event fields can be =indexed= and placed into
  topics that provide efficient search by the exact match on the indexed fields.
  The keccak256 hash of the event signature is placed into the first default
  topic. All not indexed event fields are stored in the data part of the
  transaction log

** Import

- Import :: The =import= statement imports all or explicitly selected global
  symbols from the imported file into the scope of the current file
  #+BEGIN_SRC solidity
import "path"; // Import all symbols
import { A, B as BB } "path"; // Import only selected symbols, with a rename
import * as alias from "path"; // Import all symbols under an alias
  #+END_SRC

** Layouts

- File layout ::
   - SPDX license, =pragma= Solidity compiler version
   - =import= dependencies
   - =event=, =error= global scope
   - =interface= function signatures, events
   - =library= reusable functions, events, errors
   - =contract= main building blocks
- Contract layout ::
  - =enum=, =struct= user-defined data types
  - State variables
  - =event=, =error= contract scope
  - =modifier= mostly around decorators e.g. reentrancy lock
  - =constructor=, =receive=, =fallback= singleton contract functions
  - =function= main building blocks
- Function modifiers layout ::
  - Visibility :: =private=, =internal=, =public=, =external=
  - Mutability :: =pure=, =view=, =payable=
  - Inheritance :: =virtual=, =override=
  - Modifier :: Custom modifiers

* Security

** Security principles

- Least privilege :: Grant only the minimum necessary permissions to a principal
  to perform an action. Enforce principal authorization with Solidity access
  control modifiers
- Least information :: Minimize the amount of data a function can access and
  modify
- Defensive programming :: Perform input validate and check authN and authZ
  conditions as soon as possible before executing an action
- Economy of design :: Keep it simple. Simpler is more secure. Prefer clarity
  over performance. Only use the blockchain for critical data and operations
- Open design :: Reuse tried and tested standard solutions from well-tested
  libraries, before rolling out a home-grown solution. A contract code is
  public, open for reviews and exploitation of vulnerabilities by anyone
- Fail securely :: After a failure a contract must be in a secure state by
  handling errors gracefully
- Blockchain properties :: Blockchain properties can be manipulated by miners
  e.g. =block.hash=, =block.timestamp=
  - =block.timestamp= is imprecise and should not be used as an entropy source
    for randomness on a blockchain
  - Randomness is non-trivial on a blockchain. The source of entropy must be
    external to the blockchain (a randomness oracle)
  - =block.number= is better used for time sensitive operations e.g.
    activation, expiration

** Security mechanisms

- Circuit breaker :: Use a circuit breaker to stop automatically or on demand a
  failing contract when certain conditions are met
    #+BEGIN_SRC solidity
contract C {
  bool stopped;
  function stop() public only(owner) isStopped(false) {
    stopped = true;
  }
  function deposit() isStopped(false) { }
  function withdraw() only(owner) isStopped(true) { }
}
    #+END_SRC
- Rate limiter :: Use a rate limiter and quotas to limit the frequency of
  requests and the value at risk by introducing deliberate delays in contract
  actions e.g. deferred withdrawals, deferred activation of configuration
  changes
    #+BEGIN_SRC solidity
contract C {
  struct Withdrawal { uint value; uint timestamp; }
  mapping(address => uint) balances;
  mapping(address => Withdrawal) withdrawals;
  function requestWithdrawal() public {
    address withdrawer = msg.sender;
    uint value = balances[withdrawer];
    require(value > 0, ErrNothingToWithdraw(withdrawer));
    balances[withdrawer] = 0;
    withdrawals[withdrawer] = Withdrawal(value, block.timestamp + 1 days);
  }
  function withdraw() public {
    address withdrawer = msg.sender;
    Withdrawal storage withdrawal = withdrawals[withdrawer];
    require(withdrawal.value > 0, ErrNothingToWithdraw(withdrawer));
    require(block.timestamp > withdrawal.timestamp, ErrTooEarly(withdrawer));
    uint value = withdrawal.value;
    withdrawal.value = 0;
    (bool success, ) = withdrawer.call{value: value}("");
    require(success, ErrWithdraw(withdrawer));
  }
}
    #+END_SRC

** Secure coding

*** Contract structure

- Checks-effects-interactions :: First perform all checks using the =require()=
  function. Then, make state changes by modifying state variables, even if
  recorded actions are not yet performed. Finally, perform local actions, call
  external contracts. Avoid state changes after external calls
- Isolate transactions :: Avoid combining multiple transactions into a single
  transaction. Avoid looping over an arbitrary large array whose processing may
  reach the gas limit of a block and revert the whole transaction (DoS). Split a
  large array into multiple blocks processed in isolated transactions

*** External calls

- msg.sender vs tx.origin :: If a contact =A= calls a contract =B=, and a
  contract =B= calls a contract =C=, then in the contract =C= =tx.origin= is
  =A=, and =msg.sender= is =B=. Always use =msg.sender= for authorization. Never
  use =tx.origin= for authorization. ~require(tx.origin == msg.sender)~ prevents
  intermediate contracts being used to call the current contract
- Check low-level raw calls :: Explicitly handle the success bool return value
  of low-level raw calls operating on addresses e.g. ~addr.call()`,
  ~addr.staticcall()~, ~addr.delegatecall()~. Unsuccessful calls on contract
  instances ~ctr.function()~ revert automatically
- External calls :: Treat external calls ~ctr.function()~ and external raw calls
  ~addr.call()~ to other contracts as a potential security risk
- Do not delegate call to untrusted code :: The ~addr.delegatecall()~ executes
  functions from external libraries in the context of the calling contract.
  Delegate calls only to trusted contracts. Never delegate calls to a
  user-supplied address

*** Payments

- Prefer call over transfer and send :: Prefer the ~addr.call{vaule: 1, gas:
  10}()~ (returns false on failure) over the =addr.transfer()= and
  =addr.send()=. The transfer function (reverts on failure) and the send
  functions (returns false on failure) forward only 2300 gas, which may not be
  enough if the recipient is a contract or the cost of EVM instructions changes.
  The call function forwards all available gas
  #+BEGIN_SRC solidity
// Avoid
msg.sender.transfer(value);
// Prefer
(bool succ, ) = msg.sender.call{value: value}("");
require(succ, ErrTransfer());
  #+END_SRC
- Prefer pull over push for external calls :: Minimize the damage of a failure
  of an external call by isolating the external call into its own transaction
  initiated by a recipient e.g. let users withdraw funds rather then pushing
  funds to them automatically

** Testing

- Testing strategy :: Fix bugs, introduce performance optimizations, integrate
  quality-of-life features
  - Isolated testing :: Local linting. Unit and integration testing with
    Foundry with 100% coverage. Property-based fuzzy testing with Echidna
  - Local testnet :: Deploy to a local testnet forked from the mainnet for the
    private on-chain testing in realistic conditions. Use Foundry cheatcodes to
    simulate unexpected and failure conditions
  - Public testnet :: Deploy to a public testnet for the volume testing in a
    more unpredictable environment, bug bounties, and external beta testers
  - Mainnet in beta :: Deploy to the mainnet in beta with the limited value at
    risk and extensive monitoring of the activity of a smart contract
  - Mainnet release :: Mainnet release

** Contract upgrade

- Contract upgrade :: Set up an effective upgrade path for fixes and
  improvements. Code of a deployed contract is immutable. A contract upgrade
  implies a single owner or a multisig authority with the power to trigger an
  upgrade (some centralization)
- Registry contract with redirection :: Use a registry contract that holds the
  address of the latest version of the target contract. Users must always lookup
  the latest address
  #+BEGIN_SRC solidity
contract Registry {
  address public current;
  function upgrade(address next) external only(owner) {
    require(next != address(0) && next != current, ErrInvalidContract(next));
    current = next;
    emit EvUpgrade(next);
  }
}
      #+END_SRC
- Relay contract with transparent proxy :: A relay contract stores all state
  across multiple versions of delegated logic contracts. The relay contract
  forwards calls via the =delegatecall= in the =fallback()= function to the
  latest version of the logic contract. The called logic contract must have the
  same storage layout as the calling relay contract. The relay contract only
  forwards calls, but does not return values from the logic contract. Admin
  calls are not forwarded to the logic contract, but executed directly on the
  relay contract to update its configuration
  #+BEGIN_SRC solidity
contract Relay is Registry {
  fallback() external payable {
    (bool succ, ) = current.delegatecall(msg.data);
    require(succ, ErrRelay(msg.data));
  }
}
  #+END_SRC

** Attacks

*** Frontrunning

- Frontrunning :: Every pending transaction is visible in the mempool before
  execution. The public knowledge of already submitted, but not yet processed
  transactions allows to submit and process another transaction with
  considerably higher fees targeting the same assets, before the original
  transaction is included into a block
  - Mitigation: set an upper bound on the gas price
  - Mitigation: use a commit-reveal scheme to hide transaction information in
    the commit phase and reveal the information later in the reveal phase
- Insertion :: The original transaction is processed on a modified state after
  the malicious transaction with higher fees has been processed
- Displacement :: The original transaction is processed on an already invalid
  state after the malicious transaction with higher fees has been processed
- Mitigation of frontrunning :: Reduce the benefits of frontrunning in the
  contract by minimizing the importance of transaction ordering or transaction
  timing e.g. a commit-reveal scheme
- Suppression, block stuffing :: The execution of ordinary transactions e.g.
  oracle updates is significantly delayed by placing other transactions with
  higher fees

*** Reentrancy

- Reentrancy :: A called external function performs an unanticipated external
  call back into the original calling function initiating multiple
  half-completed executions of the original function leading to a cascade of
  state changes. When a contract sends ether to an unauthorized address a
  malicious called function calls back to the original contract and reenters the
  process of sending ether until all ether is sent or the gas limit is reached.
  - Mitigation: use the checks-effects-interactions design pattern. No state
    change must occur after an external call. State changes after an external
    call enable the reentrancy vulnerability
  - Mitigation: use a reentrancy lock in the form of a mutex
  #+BEGIN_SRC solidity
contract Reentrant {
  mapping(address => unit) balances;
  bool transient locked;

  modifier lock() {
    require(!locked, "reentrant call");
    lock = true;
    _;
    lock = false;
  }

  function deposit() external payable {
    blances[msg.sender] += msg.value;
  }

  // An attacker repeatedly calls back the function until all funds of the
  // contract are drained. The attacker must stop when the contact balance or
  // the gas left is zero, otherwise the whole operation will be reverted
  function withdraw() external lock {
    address withdrawer = msg.sender;
    uint value = balances[withdrawer];
    // 1. Checks: guards against reentrant calls
    require(value > 0, ErrNothingToWithdraw(withdrawer));
    // 2. Effects: record the result of a not yet executed action
    // SAFE state change BEFORE an external call
    balances[withdrawer] = 0;
    // 3. Interactions: execute the action by performing an external call
    // Will call the Attack.receive() payable function
    (bool succ, ) = withdrawer.call{value: value}("");
    require(succ, ErrWithdraw(withdrawer));
    // UNSAFE state change AFTER the external call
    // UNSAFE record the result of already executed action
    balances[withdrawer] = 0;
  }
}

contract Attack {
  Reentrant reentrant;

  function attack() { // Provide a lot of gas for subsequent withdrawals
    // Deposit ether to have the right to withdraw
    reentrant.deposit(1);
    // Start withdrawal
    reentrant.withdraw()
  }

  receive() payable {
    // Continue withdrawal until all funds from the Reentrant contract are moved
    // to the Attack contract
    if (reentrant.balance > 0) {
      reentrant.withdraw();
    }
  }
}
  #+END_SRC


* Foundry Forge
** Cheatcodes
*** Deal balance

- Deal balance :: The =vm.deal= function
  #+BEGIN_SRC solidity
function deal(address addr, uint256 balance) external;
address own = makeAddr("owner");
vm.deal(own, 1 ether);
  #+END_SRC

*** Prank message sender

- Prank message sender :: The =vm.prank= function sets the =msg.sender= to the
  specified address for the next or subsequent calls excluding the
  =delegatecall=
  #+BEGIN_SRC solidity
function prank(address msgSender) external;
vm.prank(own);
token.transfer(rcp, 1)
function startPrank(address msgSender) external;
function stopPrank() external;
vm.startPrank(own);
token.transfer(rcp, 1)
vm.stopPrank();
  #+END_SRC

*** Assert calls

- Assert call :: The =vm.expectCall= function asserts whether a call to an
  address with the exact or the prefix match data has been made, or not made at
  all (~count = 0~)
  #+BEGIN_SRC solidity
function expectCall(
  address addr, [uint256 value], bytes calldata data, [uint64 count]
) external;
// Exact match on the calldata
vm.expectCall(address(token), abi.encodeCall(token.transfer, (rcp, 1)));
// Prefix match on a selector
vm.expectCall(address(token), abi.encodeWithSelector(token.transfer.selector));
vm.prank(own);
token.transfer(rcp, 1)
  #+END_SRC

*** Emit events

- Emit event :: The =vm.expectEmit= function asserts that a sequence of events
  is emitted by an optional emitter possibly skipping some events during the
  next call, by optionally matching the events attributes against the topic 0
  (is always matched), topics 1-3, and the data. Multiple =vm.expectEmit= +
  =emit Ev...= can be specified before the call
  #+BEGIN_SRC solidity
function expectEmit([address emitter]); // Checks all the topics and the data
function expectEmit(
    bool topic1, bool topic2, bool topic3, bool data, [address emitter]
) external;
vm.expectEmit(true, true, false, true, address(token));
emit Token.Transfer(own, rcp, 1);
vm.prank(own);
token.transfer(rcp, 1);
  #+END_SRC

*** Revert errors

- Revert error :: The =vm.expectRevert= function asserts that the next call
  reverts with the specified selector or the calldata. Only the first
  =vm.expectRevert= succeeds on internal calls (jumps) at the same call depth.
  After calling the =vm.expectRevert= calls to other cheatcoes before the
  reverting call are ignored
  #+BEGIN_SRC solidity
function expectRevert() external; // Asserts a revert with any calldata
function expectRevert(address reverter) external;
// Exact match on a selector
function expectRevert(bytes4 message, [address reverter]) external;
// Exact match on calldata
function expectRevert(bytes calldata message, [address reverter]) external;
// Partial match on a selector
function expectPartialRevert(bytes4 message, [address reverter]) external;
vm.expectRevert(ErrUnauthorized.selector);
vm.expectRevert(abi.encodeWithSelector(ErrUnauthorized.selector, msg.sender));
vm.expectPartialRevert(ErrUnauthorized.selector, address(token));
  #+END_SRC

** Cheats
*** Addresses and keys

- Make address and key ::
  #+BEGIN_SRC solidity
function makeAddrAndKey(string memory name)
  internal virtual returns (address addr, uint256 prv);
(address own, uint prv) = makeAddrAndKey("owner")
  #+END_SRC
- Make address ::
  #+BEGIN_SRC solidity
function makeAddr(string memory name) internal virtual returns (address addr);
address own = makeAddrAndKey("owner")
  #+END_SRC
